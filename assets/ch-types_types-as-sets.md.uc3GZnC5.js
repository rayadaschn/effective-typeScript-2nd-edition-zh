import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.D53w8jfx.js";const o=JSON.parse('{"title":"第 7 条：把类型看作值的集合","description":"","frontmatter":{},"headers":[],"relativePath":"ch-types/types-as-sets.md","filePath":"ch-types/types-as-sets.md"}'),e={name:"ch-types/types-as-sets.md"};function p(h,s,l,k,d,r){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="第-7-条-把类型看作值的集合" tabindex="-1">第 7 条：把类型看作值的集合 <a class="header-anchor" href="#第-7-条-把类型看作值的集合" aria-label="Permalink to &quot;第 7 条：把类型看作值的集合&quot;">​</a></h1><h2 id="要点" tabindex="-1">要点 <a class="header-anchor" href="#要点" aria-label="Permalink to &quot;要点&quot;">​</a></h2><ul><li>将类型看作值的集合（即类型的范围）。这些集合可以是有限的（例如 <code>boolean</code> 或字面量类型），也可以是无限的（例如 <code>number</code> |<code>string</code>）。</li><li>TypeScript 的类型是相交集合（可以用维恩图表示），而不是严格的层次结构。两个类型可以有重叠部分，但互相并不是子类型。</li><li>即使一个对象有额外的属性，而这些属性没有在类型声明中提到，它仍然可以属于该类型。</li><li>类型操作适用于集合的范围。例如，<code>A | B</code> 的范围是 <code>A</code> 和 <code>B</code> 的并集。</li><li>将 <code>extends</code>、&quot;assignable to&quot; 和 &quot;subtype of&quot; 理解为 &quot;子集&quot; 的同义词。</li></ul><h2 id="正文" tabindex="-1">正文 <a class="header-anchor" href="#正文" aria-label="Permalink to &quot;正文&quot;">​</a></h2><p>在运行时，每个变量都会从 JavaScript 的数值类型中选择一个具体的值。这些可能的值包括：</p><ul><li><code>42</code></li><li><code>null</code></li><li><code>undefined</code></li><li><code>&#39;Canada&#39;</code></li><li><code>{animal: &#39;Whale&#39;, weight_lbs: 40_000}</code></li><li><code>/regex/</code></li><li><code>new HTMLButtonElement</code></li><li><code>(x, y) =&gt; x + y</code></li></ul><p>在代码运行之前，当 TypeScript 在检查错误时，变量只有一个类型。可以将类型理解为一组可能的值，这个集合称为<strong>类型的取值范围（domain）</strong>。例如，<code>number</code> 类型可以看作是所有数值的集合，其中 <code>42</code> 和 <code>-37.25</code> 属于这个集合，而 <code>&#39;Canada&#39;</code> 不属于。具体来说，<code>null</code> 和 <code>undefined</code> 是否属于该集合，取决于 <code>strictNullChecks</code> 选项的设置。</p><blockquote><p>在 TypeScript 的文档或相关资料中，你不会经常看到“domain”（取值范围）这个术语，甚至在本书的其他部分也很少出现。通常，我们会把类型与其对应的值集合视为同一回事。但在本节中，我们需要一个专门的术语来指代某个类型对应的值集合，而不是类型本身，因此这里会使用“domain”来表示这一概念。</p></blockquote><p>最小的集合是空集，它不包含任何值。在 TypeScript 中，它对应的是 <code>never</code> 类型。由于它的“domain”（取值范围）是空的，因此没有任何值可以赋给 <code>never</code> 类型的变量：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> never</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 12</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ~ Type &#39;number&#39; is not assignable to type &#39;never&#39;.</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/MYewdgzgLgBAHgLhmApgNxQJxgXhgRgCYBuAKAHpyZqYA-GAFQE8AHFGAcjAFcBbAIywcYASwjIQsAIYQIIgOZgp-ADbsoIGFFbsu6IQDpSQA" target="_blank" rel="noreferrer">💻 playground</a></p><p>由于<code>never</code>位于类型层级的最底层，它有时被称为&quot;底部类型&quot;。</p><p>再往上的最小集合是仅包含单个值的集合，在 TypeScript 中，它们对应于字面量类型。（在其他语言中，这类类型有时被称为“单元类型”（unit types）。）</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;A&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;B&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Twelve</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 12</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/C4TwDgpgBAglC8UDkMkG4BQpJQEIOV3S3GgBUB3CAGwDdpEBGAJkyA" target="_blank" rel="noreferrer">💻 playground</a></p><p>要创建具有两个或三个值的类型，可以使用字面量类型联合：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AB</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;A&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;B&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AB12</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;A&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;B&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 12</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/C4TwDgpgBAggQlAvFA5DFUA+q4oNwBQokscAjAExKrpY4baWFA" target="_blank" rel="noreferrer">💻 playground</a></p><p>联合类型的“domain”（取值范围）是其组成类型“domain”（取值范围）的并集，如图所示。这正是&quot;联合类型&quot;中&quot;联合&quot;一词的含义。</p><p><img src="https://cdn.jsdelivr.net/gh/rayadaschn/blogImage@master/img/202503272316946.png" alt="Values and types as sets of values. e boxes are values (&quot;A&quot;, &quot;B&quot;, 12) and
the rounded shapes are types (A, B, AB, AB12, Twelve), which include a set of values. One
type is assignable to another if it’s entirely contained within it."></p><p>“assignable”（可赋值）这个词在 TypeScript 的错误信息中经常出现。在值集合的上下文中，它的含义可以是：</p><ul><li>对于值和类型的关系，表示“属于”（member of）。</li><li>对于两个类型的关系，表示“子集”（subset of）。</li></ul><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AB</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;A&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // OK, value &#39;A&#39; is a member of the set {&#39;A&#39;, &#39;B&#39;}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AB</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;C&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ~ Type &#39;&quot;C&quot;&#39; is not assignable to type &#39;AB&#39;</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/C4TwDgpgBAggQlAvFA5DFUA+q4oNwBQokscAjAExKrpY4baWEDGA9gHYDOwUAhgFylqafFCgB6cVADyAaQA0UAG68ANgFdoIqAEtOfKAFsIhgEYQATlFYAzKMAAW0ThB4BvEYpS4AvgTZcPMyC8MIAwvgEkmJiAH5QACrgWgBEYSkYelDsrDy8nJw6AObsvKaq0MCs9sk0uARAA" target="_blank" rel="noreferrer">💻 playground</a></p><p>类型 <code>&quot;C&quot;</code> 是一个字面量类型，它的“domain”（取值范围）只包含单个值 <code>&quot;C&quot;</code>。这个“domain”（取值范围）并不是类型 <code>&quot;AB&quot;</code>（包含 <code>&quot;A&quot;</code> 和 <code>&quot;B&quot;</code> 这两个值）的子集，所以会报错。归根结底，TypeScript 的类型检查器本质上就是在判断一个集合是否是另一个集合的子集。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK, {&quot;A&quot;, &quot;B&quot;} is a subset of {&quot;A&quot;, &quot;B&quot;}:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ab</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AB</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">random</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;A&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;B&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ab12</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AB12</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ab </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK, {&quot;A&quot;, &quot;B&quot;} is a subset of {&quot;A&quot;, &quot;B&quot;, 12}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> twelve</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AB12</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> back</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AB</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> twelve</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ~~~~ Type &#39;AB12&#39; is not assignable to type &#39;AB&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//           Type &#39;12&#39; is not assignable to type &#39;AB&#39;</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/C4TwDgpgBAggQlAvFA5DFUA+q4oNwBQokscAjAExKrpY4baWED0zUA8gNIA0UA3gCIYA3gLgCAvlACWAZygBDKLICuAI1kRgUAPYAzfkJFQxkgFwEAxjoB2s7QrVnS1ALILgACwB0AJwU2ACY6ALYAFACUUAA8UAAM3gCsUAD8NBjOKLiE1nYOapTO8JTUjnhQUKwcPIbCouJScorK6pra+rXGpryUEgQEgRCWADYKvtDDWlDAAO4QwwBuEEXkFDm29lBqCpYA1ivUs-NLLGwVUAB+VxdQACrg0GirGE02Og6ystIA5jaOk9MdNMHjRcAQqudIed7iQUJQXvI3h8vr9-tBgEDiI94CgCEA" target="_blank" rel="noreferrer">💻 playground</a></p><p>这些类型的集合相对容易推理，因为它们是有限的。你可以逐个比较元素。但在实践中使用的大多数类型具有无限“domain”（取值范围）。对它们的推理会更困难。你可以将它们视为通过列出其元素构建的。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // | ...</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/C4TwDgpgBAkgdsKBeKBGKAfKAmTUDMeALHgKxQD0FeAdHQFBA" target="_blank" rel="noreferrer">💻 playground</a></p><p>或者可以通过描述其成员来构建：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Identified</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgJIBMLmDYF3IDeAUMssOgFzIDOYUoA5gNzEC+xQA" target="_blank" rel="noreferrer">💻 playground</a></p><p>可以把这个接口理解为对其类型“domain”（取值范围）的描述：这个值是一个对象吗？它是否有一个 <code>id</code> 属性，并且该属性的值可以赋给 <code>string</code> 类型？如果是，那它就是 <code>Identified</code> 类型。</p><p>这就是它的全部含义。正如第 4 条所解释的，TypeScript 采用结构化类型系统，因此这个值还可以包含其他属性，甚至可以是一个可调用的对象！不过，在某些情况下，过多的额外属性检查（见第 11 条）可能会让这一点变得不那么明显。</p><p>将类型视为值的集合，有助于你更好地理解它们的操作方式。例如：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Lifespan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  birth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  death</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PersonSpan</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Lifespan</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgJIBMLmDYF3IDeAUMssOgFzIDOYUoA5gNzEC+xoksiKACtBoB7EEVLIQcALYRqdBiBbtO4aPCTIAMjgg0ADnFEkyAI2BQwAC2oAROJFZlM9ywH5b9iKw5gAnnv5BEQBlA1EAXmQBKGFRADItHX1DViA" target="_blank" rel="noreferrer">💻 playground</a></p><p><code>&amp;</code> 运算符计算的是两个类型的交集。那么，什么样的值属于 <code>PersonSpan</code> 类型呢？乍一看，<code>Person</code> 和 <code>Lifespan</code> 接口没有共同的属性，因此你可能会认为它是一个空集合（即 <code>never</code> 类型）。但实际上，类型操作是作用于值的集合（即类型的“domain”），而不是接口中的属性。而且要记住，具有额外属性的值仍然属于某个类型。因此，一个同时拥有 <code>Person</code> 和 <code>Lifespan</code> 属性的值将属于交集类型。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ps</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PersonSpan</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Alan Turing&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  birth: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1912/06/23&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  death: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1954/06/07&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgJIBMLmDYF3IDeAUMssOgFzIDOYUoA5gNzEC+xoksiKACtBoB7EEVLIQcALYRqdBiBbtO4aPCTIAMjgg0ADnFEkyAI2BQwAC2oAROJFZlM9ywH5b9iKw5gAnnv5BEQBlA1EAXmQBKGFRADItHX1DVgQROmQ9Gmpo2NDDZEjjCWlZZAByAEEAGwKAFQBXBUZygBpxMwtrCQgAd2Q7SAAKcoBGAE5RgCYAegAGADYZqYBmcoBKdqcIF2oQPoHPEYmAVgAWeaW5gHYN9rZmMhmZ5AB5AGliIA" target="_blank" rel="noreferrer">💻 playground</a></p><p>当然，一个值可以拥有比这三个属性更多的属性，但仍然属于该类型！一般规则是：交集类型中的值包含其组成部分中所有属性的联合。</p><p>关于属性交集的直觉是正确的，但这适用于两个接口的并集（union）而非它们的交集（intersection）。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> K</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> keyof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Lifespan</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//   ^? type K = never</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgJIBMLmDYF3IDeAUMssOgFzIDOYUoA5gNzEC+xoksiKACtBoB7EEVLIQcALYRqdBiBbtO4aPCTIAMjgg0ADnFEkyAI2BQwAC2oAROJFZlM9ywH5b9iKw5gAnnv5BEQBlA1EAXmQBKGFRADItHX1DVj8A5ABpZEiAawhfIRhkAApo2OQAH0SYXTCASlYAekayZAA9V2Q0lCzIkAgAN2hiIA" target="_blank" rel="noreferrer">💻 playground</a></p><p>由于 TypeScript 无法确定联合类型中的值必定存在哪些键，因此该联合类型的 <code>keyof</code> 结果必然是空集（即 <code>never</code> 类型）。或者更正式地说：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Disclaimer: these are relationships, not TypeScript code!</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">keyof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (keyof </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (keyof </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">keyof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (keyof </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (keyof </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>如果你能直观地理解为什么这些方程成立，那说明你对 TypeScript 类型系统的已经非常熟悉了。</p><p>当然更符合开发习惯的写法是使用 <code>extends</code> 来定义 <code>PersonSpan</code> 类型：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PersonSpan</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  birth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  death</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyIcAthAFzIZhSgDmA3AQL4GiSyIrpTYgAygAc4uCAA9IIACYY0mHPiLIARsChgAFtQAicSC2IyIBrQH49BiC3ZA" target="_blank" rel="noreferrer">💻 playground</a></p><p>把类型看作是值的集合，那么 <code>extends</code> 表示什么呢？就像 “assignable to” 一样，你可以把它理解为 “子集”。每个 <code>PersonSpan</code> 类型的值必须有一个 <code>name</code> 属性，它的值是一个字符串。同时，每个值还必须有一个 <code>birth</code> 属性，所以它是一个真正的子集。</p><p>虽然 <code>extends</code> 通常用于向接口添加字段，但任何匹配基础类型子集的值也可以。这让你能够建模更细致的类型关系：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NullyStudent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  ageYears</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Student</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NullyStudent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  ageYears</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgHIFcA2mCeBlMdAEwnGQG8AoZZEOAWwgC5kBnMKUAcwG5rk4XCAE0IcKKxYh09AEbRkAH1pZMfAL6VQkWIhQFipMMggAPSCCKs0q-IRJkqNQSLESpM+VA2UgA" target="_blank" rel="noreferrer">💻 playground</a></p><p>并不是每种语言都允许像这样修改 <code>ageYears</code> 的类型，但只要它能赋值给基础类型（<code>NullyStudent</code>）中的类型，TypeScript 是允许的。当你考虑这两个接口的“domain”时，这就有意义了。如果你试图扩展 <code>ageYears</code> 的类型，反而会得到一个错误：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StringyStudent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NullyStudent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //      ~~~~~~~~~~~~~~</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Interface &#39;StringyStudent&#39; incorrectly extends interface &#39;NullyStudent&#39;.</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  ageYears</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgHIFcA2mCeBlMdAEwnGQG8AoZZEOAWwgC5kBnMKUAcwG5rk4XCAE0IcKKxYh09AEbRkAH1pZMfAL6VQkWIhQFipMMggAPSCCKs0q-IRJkqNQSLESpM+VA1bw0eEjIBJwgXHaGZGYWVjbY4Q7GTsgA9Mk06cgAftk5ubn8qcgAkn66gQDkwdzxRuXIoAgA9lBQEAhguCbmpDHa-nrI5RhxBgnlAHT8LqLikipyCsrsIbyUmkA" target="_blank" rel="noreferrer">💻 playground</a></p><p>你可能会听到“子类型”这个术语。这是另一种说法，意味着一个类型的范围是另一个类型范围的子集。可以通过一维、二维和三维向量来理解：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vector1D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vector2D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vector1D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vector3D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vector2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  z</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgGoQWA9lAjAEWQG9kAPALmRAFcBbAI2gG5kBfAKFElkRXUxwAmQhFKQQAEwDOaDNjyESAT0o0GzNp3DR4SWQKgBmEWIiSZ-ecOLIAXqrqMoLDkA" target="_blank" rel="noreferrer">💻 playground</a></p><p>你可以说 <code>Vector3D</code> 是 <code>Vector2D</code> 的子类型，而 <code>Vector2D</code> 又是 <code>Vector1D</code> 的子类型（在类的上下文中，你可以说它是“子类”）。这种关系通常以层级结构表示，但从值的集合角度来看，使用维恩图更合适。</p><p><img src="https://cdn.jsdelivr.net/gh/rayadaschn/blogImage@master/img/202503272329611.png" alt="Two ways of thinking of type relationships: as a hierarchy or as overlapping sets."></p><p>通过维恩图可以清楚地看到，即使不使用 <code>extends</code> 重写接口，子集/子类型/可赋值性关系依然保持不变。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vector1D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vector2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vector3D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  z</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgGoQWA9lAjAEWQG9kAPALmRAFcBbAI2gG5kBfAKFElkRXUxwAmQiQpU6jKCwCelGg2ZtO4aPCRoM2KAGYRZORMWzxCqcgBeB0yw5A" target="_blank" rel="noreferrer">💻 playground</a></p><p>集合没有改变，所以维恩图也没有改变。</p><p>虽然这两种解释对于对象类型都适用，但当你开始考虑字面量类型和联合类型时，集合的解释会变得更直观。</p><p><code>extends</code> 关键字也可以出现在泛型类型的约束中，在这种情况下，它也表示“子集”。（第 15 条）</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">K</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/GYVwdgxgLglg9mABAcwKZQNKoJ4B4OKoAeUqYAJgM6KVQBOMYyAfABQBuAhgDYBcinMNgA0iANY5+GAJSIA3gChEiAPQrEAOi0KAvgqA" target="_blank" rel="noreferrer">💻 playground</a></p><p>扩展 string 类型&quot;意味着什么？如果你习惯于从对象继承的角度思考，这很难解释。你可以定义对象包装类型 <code>String</code> 的子类（参见第 10 条），但这似乎并不可取。</p><p>从集合的角度思考，任何“domain”（取值范围）是 string 子集的类型都适用。这包括字符串字面量类型、字符串字面量类型的联合类型、模板字面量类型（第 54 条）以及 string 类型本身：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({}, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;x&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK, &#39;x&#39; extends string</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({}, Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">random</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;a&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;b&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK, &#39;a&#39;|&#39;b&#39; extends string</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({}, document.title) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK, string extends string</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         ~~ Type &#39;number&#39; is not assignable to parameter of type &#39;string&#39;</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/GYVwdgxgLglg9mABAcwKZQNKoJ4B4OKoAeUqYAJgM6KVQBOMYyAfABQBuAhgDYBcinMNgA0iANY5+GAJSIA3gChEiAPQrEAOi0KAvgrSYcrOTtEByImekBuZWsQB5DOcuESZKjXqNk+9FmxjU0QAWU4oAAsNOkFyOABbVllcRAAGDQBWRAB+RDNOM0R+MwAjK1tVdSdzAoAfUsLiUgpqWgYmP0NAk1E4iBB4sigNWChuVBs7KucvduQ3Zs82n06AoNEARgAmGwV7ZQODgD8jxAAVbAAHVDywAZLUOkKYajA4KAFKShhkME4S8aIKBwRCXTgxQakOiIODAIFXG5mZZMMwKIA" target="_blank" rel="noreferrer">💻 playground</a></p><p>在上一个错误中，<code>extends</code> 变成了“assignable”，但这不会让我们困惑，因为我们知道两者都可以理解为“子集”。</p><p>当类型之间的关系不是严格层次化时，集合的解释也更有意义。例如，<code>string|number</code> 和 <code>string|Date</code> 之间是什么关系？它们的交集是非空的（是 <code>string</code>），但它们不是彼此的子类型。尽管这些类型不适合严格的层次结构，它们的范围关系仍然清晰。</p><p><img src="https://cdn.jsdelivr.net/gh/rayadaschn/blogImage@master/img/202503272334242.png" alt="Union types may not t into a hierarchy but can be thought of in terms of sets of values"></p><p>将类型视为集合的思考方式也能澄清数组和元组之间的关系。例如：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> list</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ^? const list: number[]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tuple</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ~~~~~ Type &#39;number[]&#39; is not assignable to type &#39;[number, number]&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//          Target requires 2 element(s) but source may have fewer</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/GYVwdgxgLglg9mABAcwKZQNKoJ4B4OKoAeUqYAJgM6KVQBOMYyAfABQBuAhgDYBcinMNgA0iANY5+GAJSIA3gChEiAPQrEAOi0KAvgogJaibjCMBeRAG0AjKIBMAXQDcCtcuUA9APyIDYIya0-GAgALYARqh0lg76hlCIUCAADtyo-JYhEVGiWZF0DogWgVAubu4AflVViAAq2MmoiADkeVExzYimiGBwCZyUlDDIYJzhaYlwiQ1NzZlh+bkLUQ7Nrurum8q1nHRoCXSoAI4gMIfUdoRpoWRQrJSy4SAJlHAgdBBNoZzYiAAWnHYTWAqAA7lEFEA" target="_blank" rel="noreferrer">💻 playground</a></p><p>是否存在不是数字对的元组？当然！空数组和<code>[1]</code>就是例子。因此<code>number[]</code>不能赋值给<code>[number, number]</code>是合理的，因为它不是后者的子集（反向赋值是可行的）。</p><p>三元组能赋值给二元组吗？从结构类型角度思考，你可能会认为可以。一个二元组有 0 和 1 个键，那它是不是也可能有其他键（比如 2）？</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> triple</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> double</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> triple</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ~~~~~~ &#39;[number, number, number]&#39; is not assignable to &#39;[number, number]&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//           Source has 3 element(s) but target allows only 2.</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/GYVwdgxgLglg9mABAcwKZQNKoJ4B4OKoAeUqYAJgM6KVQBOMYyAfABQBuAhgDYBcinMNgA0iANY5+GAJSIA3gChEiAPQrEAOi0KAvgogJaiejAAO3VPwDaYEAFsARqjqjbj56-tO6AXUQBeRCsARlEAJlEAZh8Abn1DKERyOBAHC2s3b093XwDjBnNUOLVlZQA-CsrEAHIbLw9ETIam32rEGGowOETOSkoYZDBONNRjOBq6nOzvH2qFEtLF0oBlFLoIUYALXsRIwgs7MihWSlkHEESoTjo0Hu5uOAB3agRubEQwjQUgA" target="_blank" rel="noreferrer">💻 playground</a></p><p>答案是&quot;不能&quot;，这里有个有趣的原因。TypeScript 并非将数字对建模为<code>{0: number, 1: number}</code>，而是建模为<code>{0: number, 1: number, length: 2}</code>。这很合理：你可以检查元组的长度，这也阻止了此类赋值。</p><p>TypeScript 会不断进行可赋值性检查，正如你已经多次看到的那样，这是一种子集/子类型关系。有趣的是，TypeScript 很少检查类型完全相等。这使得为类型编写测试变得具有挑战性，这点将在第 55 条讲到。</p><p>如果最好将类型视为值的集合，那么意味着具有相同值集合的两个类型是相同的。事实上，除非两个类型在语义上不同，且恰好具有相同的范围，否则没有理由重复定义相同的类型。</p><p>与<code>never</code>（空类型）完全相反的是<code>unknown</code>。这种类型的“domain”（取值范围）包含 JavaScript 中的所有值。所有类型都可赋值给<code>unknown</code>。由于它位于类型层次结构的顶端，被称为&quot;顶层类型&quot;。第 46 条将介绍如何在代码中使用<code>unknown</code>类型。</p><p>最后值得注意的是，并非所有值集合都对应 TypeScript 类型。TypeScript 没有表示所有整数的类型，也没有表示仅包含 <code>x</code> 和 <code>y</code> 属性的对象类型。有时可以使用<code>Exclude</code>来减少类型，但只有当结果是一个有效的 TypeScript 类型时才可以：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Exclude</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//   ^? type T = Date</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NonZeroNums</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Exclude</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//   ^? type NonZeroNums = number</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/GYVwdgxgLglg9mABAcwKZQNKoJ4B4OKoAeUqYAJgM6KVQBOMYyAfABQBuAhgDYBcinMNgA0iANY5+GAJSIA3gChEiAPQrEAOi0KAvgqjYADqkQAVRAF5EAUSIRuIcqly0GTAD4ARTqVGvGyO5gIAC2AEaodMwA3ApqyogAegD8iAbGZpaI3qT6RiYAcggAWpFwBaHUVrb2js7B4ZGiAAwxcerKKWn5iEVgpXTllVkNEXQKQA" target="_blank" rel="noreferrer">💻 playground</a></p><p>下面表格总结了 TypeScript 术语与集合论术语之间的对应关系。</p><table tabindex="0"><thead><tr><th>TypeScript 术语</th><th>集合论术语</th></tr></thead><tbody><tr><td>never</td><td>∅（空集合）</td></tr><tr><td>字面量类型</td><td>单元素集合</td></tr><tr><td>可以赋值给 T 的 Value</td><td>Value ∈ T（属于）</td></tr><tr><td>T1 可以赋值给 T2</td><td>T1 ⊆ T2（子集）</td></tr><tr><td><code>T1 extends T2</code></td><td>T1 ⊆ T2（子集）</td></tr><tr><td><code>T1|T2</code></td><td>T1 ∪ T2（并集）</td></tr><tr><td><code>T1 &amp; T2</code></td><td>T1 ∩ T2（交集）</td></tr><tr><td>unknown</td><td>全集</td></tr></tbody></table><p>这种解释有一个重要的注意事项：当你将值视为不可变时效果最佳。例如，以下两种类型有什么区别？</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Lockbox</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  code</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReadonlyLockbox</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> code</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/GYVwdgxgLglg9mABAcwKZQNKoJ4B4OKoAeUqYAJgM6KVQBOMYyAfABQBuAhgDYBcinMNgA0iANY5+GAJSIA3gChEiAPQrEAOi0KAvgsak6wThFSIAMnAhiARnCLyliCHHKp+YEAFsbqOgG5dfTBDY1NEACVUTnIEbmxLazsHRWU6aNiweOdXd0RPHz9AvSA" target="_blank" rel="noreferrer">💻 playground</a></p><p>这两种类型的取值范围完全相同，但它们在实际使用中是可区分的：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> box</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Lockbox</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { code: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4216</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> robox</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReadonlyLockbox</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { code: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3625</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">box.code </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1234</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ok</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">robox.code </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1234</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ~~~~ Cannot assign to &#39;code&#39; because it is a read-only property.</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/GYVwdgxgLglg9mABAcwKZQNKoJ4B4OKoAeUqYAJgM6KVQBOMYyAfABQBuAhgDYBcinMNgA0iANY5+GAJSIA3gChEiAPQrEAOi0KAvgsak6wThFSIAMnAhiARnCLyliCHHKp+YEAFsbqOgG5dfTBDY1NEACVUTnIEbmxLazsHRWU6aNiweOdXd0RPHz9AvRcwWkRk-kTbe0QAXnkct34AFgAmAEYANkQdQNLyujhKyIy4hKsahwa5JryAZi62gFZewOSNFzd6xA62+Zb-ZTVEODEFIY2tswa9g8CT5UQAP1fnxABhQTA4KAFKSgwZBIKBwRAAcmu4IqqAgnBAlDMMD+MGonEQ6RiAFpxogAA5DPF+KDYDQKIA" target="_blank" rel="noreferrer">💻 playground</a></p><p>因此，你有时也会听到这种观点：“类型是值的集合，以及你可以对它们执行的操作。” 第 14 条会更详细地讨论 <code>readonly</code>，但总体而言，当你使用不可变值时，类型检查器会更有效。</p><h2 id="关键点总结" tabindex="-1">关键点总结 <a class="header-anchor" href="#关键点总结" aria-label="Permalink to &quot;关键点总结&quot;">​</a></h2><ul><li>将类型看作值的集合（即类型的范围）。这些集合可以是有限的（例如 <code>boolean</code> 或字面量类型），也可以是无限的（例如 <code>number</code> 或 <code>string</code>）。</li><li>TypeScript 的类型是相交集合（可以用维恩图表示），而不是严格的层次结构。两个类型可以有重叠部分，但互相并不是子类型。</li><li>即使一个对象有额外的属性，而这些属性没有在类型声明中提到，它仍然可以属于该类型。</li><li>类型操作适用于集合的范围。例如，<code>A | B</code> 的范围是 <code>A</code> 和 <code>B</code> 的并集。</li><li>将 <code>extends</code>、&quot;assignable to&quot; 和 &quot;subtype of&quot; 理解为 &quot;子集&quot; 的同义词。</li></ul>`,103)]))}const y=i(e,[["render",p]]);export{o as __pageData,y as default};
