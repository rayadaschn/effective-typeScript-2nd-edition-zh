import{_ as a,c as i,o as t,ag as l}from"./chunks/framework.D53w8jfx.js";const r="/effective-typeScript-2nd-edition-zh/cover.jpg",m=JSON.parse('{"title":"《Effective Typescript》中文第二版","description":"","frontmatter":{},"headers":[],"relativePath":"index.md","filePath":"index.md"}'),h={name:"index.md"};function c(n,e,o,s,d,p){return t(),i("div",null,e[0]||(e[0]=[l('<h1 id="《effective-typescript》中文第二版" tabindex="-1">《Effective Typescript》中文第二版 <a class="header-anchor" href="#《effective-typescript》中文第二版" aria-label="Permalink to &quot;《Effective Typescript》中文第二版&quot;">​</a></h1><p><em>提升 TypeScript 的 83 条具体方法</em></p><p><a href="https://github.com/rayadaschn" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/Author-Huy-yellow" alt="Author: Huy"></a></p><p><a href="https://opensource.org/licenses/MIT" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/License-MIT-blue.svg" alt="License"></a></p><p><img src="https://img.shields.io/github/last-commit/rayadaschn/effective-typeScript-2nd-edition-zh" alt="GitHub last commit"></p><p>原书作者：<a href="https://github.com/danvk/effective-typescript" target="_blank" rel="noreferrer">Dan Vanderkam 📚</a></p><p><img src="'+r+'" alt="Effective Typescript"></p><h2 id="第-1-章-认识-typescript" tabindex="-1">第 1 章：认识 TypeScript <a class="header-anchor" href="#第-1-章-认识-typescript" aria-label="Permalink to &quot;第 1 章：认识 TypeScript&quot;">​</a></h2><ul><li><a href="./ch-intro/ts-vs-js.html">📝 第 1 条</a>: 理解 TypeScript 与 JavaScript 的关系</li><li><a href="./ch-intro/which-ts.html">📝 第 2 条</a>: 了解你正在使用哪些 TypeScript 配置项</li><li><a href="./ch-intro/independent.html">📝 第 3 条</a>: 理解代码生成与类型系统是相互独立的</li><li><a href="./ch-intro/structural.html">📝 第 4 条</a>: 熟悉结构化类型</li><li><a href="./ch-intro/any.html">📝 第 5 条</a>: 限制 <code>any</code> 类型的使用</li></ul><h2 id="第-2-章-typescript-的类型系统" tabindex="-1"><strong>第 2 章：TypeScript 的类型系统</strong> <a class="header-anchor" href="#第-2-章-typescript-的类型系统" aria-label="Permalink to &quot;**第 2 章：TypeScript 的类型系统**&quot;">​</a></h2><ul><li><a href="./ch-types/editor.html">📝 第 6 条</a>: 使用编辑器来查询和探索类型系统</li><li><a href="./ch-types/types-as-sets.html">📝 第 7 条</a>: 把类型看作值的集合</li><li><a href="./ch-types/type-value-space.html">📝 第 8 条</a>: 了解符号处于类型空间还是值空间</li><li><a href="./ch-types/prefer-declarations-to-assertions.html">📝 第 9 条</a>: 优先使用类型注解而非类型断言</li><li><a href="./ch-types/avoid-object-wrapper-types.html">📝 第 10 条</a>: 避免使用对象包装类型（String, Number, Boolean, Symbol, BigInt）</li><li><a href="./ch-types/excess-property-checking.html">📝 第 11 条</a>: 区分多余属性检查与类型检查</li><li><a href="./ch-types/type-entire-functions.html">📝 第 12 条</a>: 尽可能为整个函数表达式应用类型</li><li><a href="./ch-types/type-vs-interface.html">📝 第 13 条</a>: 了解 <code>type</code> 与 <code>interface</code> 的区别</li><li><a href="./ch-types/readonly.html">📝 第 14 条</a>: 使用 <code>readonly</code> 防止因可变性引发的错误</li><li><a href="./ch-types/map-between-types.html">📝 第 15 条</a>: 利用类型运算和泛型减少重复</li><li><a href="./ch-types/index-for-dynamic.html">📝 第 16 条</a>: 优先使用更精确的索引签名替代方案</li><li><a href="./ch-types/number-index.html">📝 第 17 条</a>: 避免数字索引签名</li></ul><h2 id="第-3-章-类型推断与控制流分析" tabindex="-1"><strong>第 3 章：类型推断与控制流分析</strong> <a class="header-anchor" href="#第-3-章-类型推断与控制流分析" aria-label="Permalink to &quot;**第 3 章：类型推断与控制流分析**&quot;">​</a></h2><ul><li><a href="./ch-inference/avoid-inferable.html">📝 第 18 条</a>: 避免在代码中添加可推断的类型</li><li><a href="./ch-inference/one-var-one-type.html">📝 第 19 条</a>: 不同类型使用不同变量</li><li><a href="./ch-inference/widening.html">📝 第 20 条</a>: 理解变量如何获得类型</li><li><a href="./ch-inference/all-at-once.html">📝 第 21 条</a>: 一次性创建对象</li><li><a href="./ch-inference/narrowing.html">📝 第 22 条</a>: 理解类型收窄</li><li><a href="./ch-inference/avoid-aliasing.html">📝 第 23 条</a>: 保持别名使用的一致性</li><li><a href="./ch-inference/context-inference.html">📝 第 24 条</a>: 理解上下文在类型推断中的作用</li><li><a href="./ch-inference/evolving-any.html">📝 第 25 条</a>: 理解类型演变</li><li><a href="./ch-inference/functional-libraries.html">📝 第 26 条</a>: 使用函数式写法和函数式库来帮助类型推导</li><li><a href="./ch-inference/use-async-await.html">📝 第 27 条</a>: 使用 async 函数替代回调以改善类型推导</li><li><a href="./ch-inference/inference-sites.html">📝 第 28 条</a>: 用类和柯里化创建新的类型推断点</li></ul><h2 id="第-4-章-类型设计" tabindex="-1"><strong>第 4 章：类型设计</strong> <a class="header-anchor" href="#第-4-章-类型设计" aria-label="Permalink to &quot;**第 4 章：类型设计**&quot;">​</a></h2><ul><li><a href="./ch-design/valid-states.html">📝 第 29 条</a>: 尽量让你的类型只能表示合法的状态</li><li><a href="./ch-design/loose-accept-strict-produce.html">📝 第 30 条</a>: 对输入要宽松，对输出要严格</li><li><a href="./ch-design/jsdoc-repeat.html">📝 第 31 条</a>: 不要在文档中重复类型信息</li><li><a href="./ch-design/null-in-type.html">📝 第 32 条</a>: 避免在类型别名中包含 <code>null</code> 或 <code>undefined</code></li><li><a href="./ch-design/null-values-to-perimeter.html">📝 第 33 条</a>: 把 <code>null</code> 值留在类型的外层</li><li><a href="./ch-design/union-of-interfaces.html">📝 第 34 条</a>: 优先使用接口的联合类型，而不是属性为联合类型的接口</li><li><a href="./ch-design/avoid-strings.html">📝 第 35 条</a>: 使用更精确的替代方案代替字符串类型</li><li><a href="./ch-design/in-domain-null.html">📝 第 36 条</a>: 为特殊值使用特殊类型</li><li><a href="./ch-design/avoid-optional.html">📝 第 37 条</a>: 限制可选属性的使用</li><li><a href="./ch-design/same-type-params.html">📝 第 38 条</a>: 避免重复的同类型参数</li><li><a href="./ch-design/unify.html">📝 第 39 条</a>: 优先统一类型，而非细化类型差异</li><li><a href="./ch-design/incomplete-over-inaccurate.html">📝 第 40 条</a>: 宁愿类型不够精确，也不要类型不准确</li><li><a href="./ch-design/language-of-domain.html">📝 第 41 条</a>: 使用相关领域语言为类型命名</li><li><a href="./ch-design/consider-codegen.html">📝 第 42 条</a>: 避免基于个人经验设计类型</li></ul><h2 id="第-5-章-类型的不安全性与-any-类型" tabindex="-1"><strong>第 5 章：类型的不安全性与 <code>any</code> 类型</strong> <a class="header-anchor" href="#第-5-章-类型的不安全性与-any-类型" aria-label="Permalink to &quot;**第 5 章：类型的不安全性与 `any` 类型**&quot;">​</a></h2><ul><li><a href="./ch-any/narrowest-any.html">📝 第 43 条</a>: 为 <code>any</code> 类型设置尽可能小的作用域</li><li><a href="./ch-any/specific-any.html">📝 第 44 条</a>: 比起直接用 <code>any</code>，更推荐用更具体的替代类型</li><li><a href="./ch-any/hide-unsafe-casts.html">📝 第 45 条</a>: 在类型良好的函数中隐藏不安全的类型断言</li><li><a href="./ch-any/never-unknown.html">📝 第 46 条</a>: 对于未知类型的值，使用 <code>unknown</code> 替代 <code>any</code></li><li><a href="./ch-any/type-safe-monkey.html">📝 第 47 条</a>: 拒绝 Monkey Patch，拥抱类型安全</li><li><a href="./ch-any/unsoundness.html">📝 第 48 条</a>: 避免类型安全性陷阱</li><li><a href="./ch-any/type-percentage.html">📝 第 49 条</a>: 跟踪你的类型覆盖率以防止类型安全性回归</li></ul><h2 id="第-6-章-泛型与类型层级编程" tabindex="-1"><strong>第 6 章：泛型与类型层级编程</strong> <a class="header-anchor" href="#第-6-章-泛型与类型层级编程" aria-label="Permalink to &quot;**第 6 章：泛型与类型层级编程**&quot;">​</a></h2><ul><li><a href="./ch-generics/functions-on-types.html">📝 第 50 条</a>: 将泛型视为类型之间的函数</li><li><a href="./ch-generics/golden-rule.html">📝 第 51 条</a>: 避免不必要的类型参数</li><li><a href="./ch-generics/conditional-overload.html">📝 第 52 条</a>: 优先使用条件类型而非重载签名</li><li><a href="./ch-generics/control-distribution.html">📝 第 53 条</a>: 了解如何控制条件类型中的联合分布</li><li><a href="./ch-generics/template-dsl.html">📝 第 54 条</a>: 使用模板字面量类型来建模领域特定语言（DSL）及字符串之间的关系</li><li><a href="./ch-generics/test-your-types.html">📝 第 55 条</a>: 为你的类型编写测试</li><li><a href="./ch-generics/type-display.html">📝 第 56 条</a>: 注意类型的显示方式</li><li><a href="./ch-generics/tail-recursion.html">📝 第 57 条</a>: 优先使用尾递归泛型类型</li><li><a href="./ch-generics/codegen-alt.html">📝 第 58 条</a>: 将代码生成作为复杂类型的替代方案</li></ul><h2 id="第-7-章-typescript-配方" tabindex="-1"><strong>第 7 章：TypeScript 配方</strong> <a class="header-anchor" href="#第-7-章-typescript-配方" aria-label="Permalink to &quot;**第 7 章：TypeScript 配方**&quot;">​</a></h2><ul><li><a href="./ch-recipes/exhaustiveness.html">📝 第 59 条</a>: 使用 <code>never</code> 类型进行穷举检查</li><li><a href="./ch-recipes/iterate-objects.html">📝 第 60 条</a>: 了解如何遍历对象</li><li><a href="./ch-recipes/values-in-sync.html">📝 第 61 条</a>: 使用 <code>Record</code> 类型保持值的同步</li><li><a href="./ch-recipes/conditional-varargs.html">📝 第 62 条</a>: 使用 Rest 参数和元组类型来建模可变参数函数</li><li><a href="./ch-recipes/optional-never.html">📝 第 63 条</a>: 使用可选的 <code>never</code> 属性来建模独占或</li><li><a href="./ch-recipes/brands.html">📝 第 64 条</a>: 考虑使用品牌进行命名类型</li></ul><h2 id="第-8-章-类型声明与-types" tabindex="-1"><strong>第 8 章：类型声明与 @types</strong> <a class="header-anchor" href="#第-8-章-类型声明与-types" aria-label="Permalink to &quot;**第 8 章：类型声明与 @types**&quot;">​</a></h2><ul><li><a href="./ch-declarations/dev-dependencies.html">📝 第 65 条</a>: 将 TypeScript 和 <code>@types</code> 放入 <code>devDependencies</code></li><li><a href="./ch-declarations/three-versions.html">📝 第 66 条</a>: 理解类型声明中涉及的三种版本</li><li><a href="./ch-declarations/export-your-types.html">📝 第 67 条</a>: 导出所有出现在公共 API 中的类型</li><li><a href="./ch-declarations/use-tsdoc.html">📝 第 68 条</a>: 使用 TSDoc 进行 API 注释</li><li><a href="./ch-declarations/this-in-callbacks.html">📝 第 69 条</a>: 如果回调函数的 API 中包含 <code>this</code>，为其提供类型</li><li><a href="./ch-declarations/mirror-types-for-deps.html">📝 第 70 条</a>: 镜像类型以解耦依赖关系</li><li><a href="./ch-declarations/augment-improve.html">📝 第 71 条</a>: 使用模块增强改善类型</li></ul><h2 id="第-9-章-编写与运行代码" tabindex="-1"><strong>第 9 章：编写与运行代码</strong> <a class="header-anchor" href="#第-9-章-编写与运行代码" aria-label="Permalink to &quot;**第 9 章：编写与运行代码**&quot;">​</a></h2><ul><li><a href="./ch-write-run/avoid-non-ecma.html">📝 第 72 条</a>: 优先使用 ECMAScript 特性而非 TypeScript 特性</li><li><a href="./ch-write-run/source-maps-debug.html">📝 第 73 条</a>: 使用源映射调试 TypeScript</li><li><a href="./ch-write-run/runtime-types.html">📝 第 74 条</a>: 了解如何在运行时重构类型</li><li><a href="./ch-write-run/understand-the-dom.html">📝 第 75 条</a>: 理解 DOM 层级结构</li><li><a href="./ch-write-run/model-env.html">📝 第 76 条</a>: 创建准确的环境模型</li><li><a href="./ch-write-run/types-or-tests.html">📝 第 77 条</a>: 了解类型检查与单元测试之间的关系</li><li><a href="./ch-write-run/performance.html">📝 第 78 条</a>: 关注编译器性能</li></ul><h2 id="第-10-章-现代化与迁移" tabindex="-1"><strong>第 10 章：现代化与迁移</strong> <a class="header-anchor" href="#第-10-章-现代化与迁移" aria-label="Permalink to &quot;**第 10 章：现代化与迁移**&quot;">​</a></h2><ul><li><a href="./ch-migrate/write-modern-js.html">📝 第 79 条</a>: 编写现代 JavaScript</li><li><a href="./ch-migrate/jsdoc-tscheck.html">📝 第 80 条</a>: 使用 <code>@ts-check</code> 和 JSDoc 体验 TypeScript</li><li><a href="./ch-migrate/allowjs.html">📝 第 81 条</a>: 使用 <code>allowJs</code> 混合使用 TypeScript 和 JavaScript</li><li><a href="./ch-migrate/convert-up-the-graph.html">📝 第 82 条</a>: 按依赖图逐个模块升级</li><li><a href="./ch-migrate/start-loose.html">📝 第 83 条</a>: 迁移完成的标志是启用 <code>noImplicitAny</code></li></ul>',27)]))}const u=a(h,[["render",c]]);export{m as __pageData,u as default};
