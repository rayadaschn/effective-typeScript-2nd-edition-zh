import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.D53w8jfx.js";const o=JSON.parse('{"title":"第 9 条: 优先使用类型注解而非类型断言","description":"","frontmatter":{},"headers":[],"relativePath":"ch-types/prefer-declarations-to-assertions.md","filePath":"ch-types/prefer-declarations-to-assertions.md"}'),e={name:"ch-types/prefer-declarations-to-assertions.md"};function p(h,s,l,k,r,d){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="第-9-条-优先使用类型注解而非类型断言" tabindex="-1">第 9 条: 优先使用类型注解而非类型断言 <a class="header-anchor" href="#第-9-条-优先使用类型注解而非类型断言" aria-label="Permalink to &quot;第 9 条: 优先使用类型注解而非类型断言&quot;">​</a></h1><h2 id="要点" tabindex="-1">要点 <a class="header-anchor" href="#要点" aria-label="Permalink to &quot;要点&quot;">​</a></h2><ul><li>优先使用类型注解（<code>: Type</code>），少用类型断言（<code>as Type</code>）。</li><li>熟悉如何为箭头函数标注返回类型。</li><li>只有在你确信自己比 TypeScript 更清楚类型情况时，才使用类型断言或非空断言。</li><li>使用类型断言时，务必加注释解释为什么这样写是安全的。</li></ul><h2 id="正文" tabindex="-1">正文 <a class="header-anchor" href="#正文" aria-label="Permalink to &quot;正文&quot;">​</a></h2><p>TypeScript 有两种方式可以给变量赋值并指定类型：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> alice</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ^? const alice: Person</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bob</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Bob&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ^? const bob: Person</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN7IhwC2EAXMhmFKAObIC+A3AFAsI5XJwA2wSFdFGy4AvPkIlyyAOQBBPkhmNWAelXJNyAHoB+ZBxBde-aUJHtOYZACMsN5OIJFSFGQCF7yhtwxpMOGoaWnoGVrb2ggEgLEA" target="_blank" rel="noreferrer">💻 playground</a></p><p>虽然它们实现的效果差不多，但其实差别很大！第一种（<code>alice: Person</code>）是给变量加了一个类型注解，确保赋的值符合这个类型。第二种（<code>as Person</code>）是<strong>类型断言</strong>，意思是告诉 TypeScript：“我知道你推断的类型，但我更了解这个值的实际类型，我说它就是 <code>Person</code>。”</p><p>通常来说，你应该优先使用类型注解，而不是类型断言。原因如下：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> alice</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ~~~~~ Property &#39;name&#39; is missing in type &#39;{}&#39; but required in type &#39;Person&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bob</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // No error</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN7IhwC2EAXMhmFKAObIC+A3AFAI5XJwA2wSF6KNlwBefMxYB6SclnIAfosVooWAA7QwAT2QByIqV3JgGZMRMY6x3No168DIwCMArmGRQIARxfBPAE2tkWxRdQWFdNg53JywnZDEHLlNwnCZZaWQAOSxkaFUoFiA" target="_blank" rel="noreferrer">💻 playground</a></p><p>类型注解会检查这个值是否符合接口的要求。如果不符合，TypeScript 就会报错。而类型断言则会“屏蔽”这个错误，意思是无论什么原因，你告诉 TypeScript：“我比你更清楚这个值的类型。”</p><p>如果你多写了一个属性，情况也是一样的：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> alice</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  occupation: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;TypeScript developer&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ~~~~~~~~~ Object literal may only specify known properties,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //           and &#39;occupation&#39; does not exist in type &#39;Person&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bob</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Bob&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  occupation: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;JavaScript developer&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // No error</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN7IhwC2EAXMhmFKAObIC+A3AFAI5XJwA2wSF6KNlwBefC2SES5ZAHIAgrySyANBORYECAK4AHOGGA4KsgCoBPXRADKCGrrDIAJhABuEblitRZLAPR+yAB+IaGhyADyAEYAVhAIjryQUDzIxHDmGiDcmRhWCMAwmQDWIFgA7ri6UF7QhhAYagGSLa2ScCBOcpo6+oY4ss5YDYRYjhAAHsCcoMhgliiygsK+zGwcjlFYUchieOpEpCYAQtuq6j16BkYgJgBScK5wtvaOLu6e3qtcGGiYOExJM0AHJYZDQGpQFhAA" target="_blank" rel="noreferrer">💻 playground</a></p><p>从结构类型的角度来看（见第 4 条），多写的属性是合法的，但通常都是写错了。TypeScript 提供了一种额外的检查机制，叫做“多余属性检查”，它能在对象有多余属性时发出警告，不过这个警告在你用类型断言时是不会生效的。第 11 条会详细讲这个检查机制。</p><p>正因为类型注解能提供更多安全检查，除非你有特别明确的理由，否则应该优先使用类型注解，而不是类型断言。</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>你可能还会看到像 <code>const bob = &lt;Person&gt;{}</code> 这样的代码。这是早期的类型断言语法，和 <code>{}</code> as Person 是一样的。不过现在不太常用了，因为在 <code>.tsx</code> 文件（TypeScript + React）中，<code>&lt;Person&gt;</code> 会被当作一个 HTML 标签的开始标签来解析。</p></div><p>在箭头函数中使用类型注解有时候会比较麻烦。如果你想在这段代码里用上 <code>Person</code> 这个命名接口，该怎么办呢？</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> people</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bob&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;jan&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ name }))</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// { name: string; }[]... but we want Person[]</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN7IhwC2EAXMhmFKAObIC+A3AFAI5XIAOEWXANigC8yANoByOP2BJxAGmTiARliXzFAKzghxAXQB0xOFwAURUsiEA+ZCbzmIDAJRPWAejf5CJcpWp0mRlEDfX1kJQBXMGQAdxQY7Wj0KGwQYJYgA" target="_blank" rel="noreferrer">💻 playground</a></p><p>在这里你可能会忍不住想用类型断言，看起来好像也能解决问题：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> people</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bob&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;jan&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ name } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Type is Person[]</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN7IhwC2EAXMhmFKAObIC+A3AFAI5XIAOEWXANigC8yANoByOP2BJxAGmTiARliXzFAKzghxAXQB0xOFwAULZIRLCAfMhN4ipBsjgY0mHAEoWnpsgD0-sgAKgCePMjAbuhQ2CCiuixAA" target="_blank" rel="noreferrer">💻 playground</a></p><p>但这种写法也会遇到和直接使用类型断言一样的问题。比如说：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> people</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bob&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;jan&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// No error</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN7IhwC2EAXMhmFKAObIC+A3AFAI5XIAOEWXANigC8yANoByOP2BJxAGmTiARliXzFAKzghxAXQB0xOFwAURUsiEA+ZCbwNkcDGkw4AlG9YB6L8gByWMjQUFhQLEA" target="_blank" rel="noreferrer">💻 playground</a></p><p>那在这种情况下该怎么用类型注解呢？最直接的方式就是在箭头函数里先声明一个变量：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> people</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bob&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;jan&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Type is Person[]</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN7IhwC2EAXMhmFKAObIC+A3AFAI5XIAOEWXANigC8yANoByOP2BJxAGmTiARliXzFAKzghxAXQB0xOFwAURUsiEA+fC2TJ2ITjyjYQFdK5yX85iMztkKAgwAFcoXBc3FgYASiZkAHpE5AAVAE8eZGAMNEwcUV0WIA" target="_blank" rel="noreferrer">💻 playground</a></p><p>不过，这样做相比原始代码会引入不少冗余。更简洁的方式是注解箭头函数的返回类型：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> people</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bob&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;jan&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ name })) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Type is Person[]</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN7IhwC2EAXMhmFKAObIC+A3AFAI5XIAOEWXANigC8yANoByOP2BJxAGmTiARliXzFAKzghxAXQB0xOFwAULZMhNFSASgroo2XEIB8lvNYgMbLG02QA9AHIACoAnjzIwBhomDiiuixAA" target="_blank" rel="noreferrer">💻 playground</a></p><p>这和之前的版本一样，会对值进行相同的检查。这里的圆括号非常重要！<code>(name): Person</code> 允许推断 <code>name</code> 的类型，并指定返回类型应该是 <code>Person</code>。但如果写成 <code>(name: Person)</code>，则会指定 <code>name</code> 的类型为 <code>Person</code>，同时让返回类型推断，这样会导致错误。关于函数参数的类型推断，详见第 24 条。</p><p>在这种情况下，你也可以直接写出最终的期望类型，让 TypeScript 来检查赋值是否有效：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> people</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bob&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;jan&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ name })) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN7IhwC2EAXMhmFKAObIC+A3AFAI5XIAOEWXANuTSYcAbQC6yALzJRAcjj9gSOQBpkcgEZZNajQCs4IOeIB0xOFwAURUtIB8yK3lsQGASndNkAeh-IAeQBpFiA" target="_blank" rel="noreferrer">💻 playground</a></p><p>但在较长的函数调用链中，可能需要或更希望早点使用命名类型，这样能更快发现错误，定位问题也更精确。</p><p>那么，什么时候应该使用类型断言呢？类型断言最适合在你确实比 TypeScript 更了解某个类型的时候，通常这种情况是因为有些上下文信息类型检查器无法获取到。比如说，如果你在浏览器中工作，你可能比 TypeScript 更清楚一个 DOM 元素的类型：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#myButton&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  e.currentTarget</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ^? (property) Event.currentTarget: EventTarget | null</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // currentTarget is #myButton is a button element</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> button</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e.currentTarget </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HTMLButtonElement</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //    ^? const button: HTMLButtonElement</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/CYewxgrgtgpgdgFwHQEcIwE4E8DKMA2MYCIGAFAOQDEUWAQhAiXBQJQD8SAhsMAKIA3eAgAyASwDOCeJkph8YsAGsKAGgAEMdQF4AfOoDeAKHWakkDBmEAVLhgDmMBCfUB6V+oB67dWQAOGCB+mAhYrOqCwuYQljZ2jggAXBFCiLYOTuoAPupwEPj4Lu7qFlZp8ZmS6jT0jMzqVVzqAEZ1IHCahLCILmDtUi1tHdpmpXEZCOpcEuoAEtYAsiIMTO18XcIA3EUepl4+fXADratwyfNLK8zrMN3OAL6s20A" target="_blank" rel="noreferrer">💻 playground</a></p><p>因为 TypeScript 无法访问页面的 DOM，它不知道 <code>#myButton</code> 是一个按钮元素，也不知道当前事件的 Target 应该是这个按钮。由于你有 TypeScript 无法获取的信息，因此在这里使用类型断言是合理的。有关 DOM 类型的更多信息，请参见第 75 条。</p><p>使用类型断言时，最好在注释中解释为什么它是有效的。这为人类读者提供了缺失的信息，帮助他们判断这个断言是否仍然成立。</p><p>如果一个变量的类型包含了 <code>null</code>，但你从上下文中知道这不可能是 <code>null</code>，你可以使用类型断言来移除 <code>null</code>：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> elNull</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ^? const elNull: HTMLElement | null</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HTMLElement</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ^? const el: HTMLElement</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/MYewdgzgLgBApgGwHIFcEJgXhgExMFAWzjCgDoBzOKAUQTmNICEBPASRwAoByAMxBDcAlAG4AUAHoJMGTAB6AfhihIsRKnQAuGAAkAKgFkAMnQYlYAHxhg0CMSujwM2PAUbkqteu9Yce-QSEYAEMIXUMTb3NxKVl5JQc1BG19Y1N3MSA" target="_blank" rel="noreferrer">💻 playground</a></p><p>这种类型断言非常常见，以至于它有了专门的语法，称为“非空断言”：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ^? const el: HTMLElement</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/MYewdgzgLgBApgGxgXhgExMArgWzmKAOgHM4oBRBOPAgIQE8BJNACgHIAzEENgSgEIA3ACgA9KJiSYAPQD8MUJFiIAXDAASAFQCyAGUrV8UYUA" target="_blank" rel="noreferrer">💻 playground</a></p><p>作为前缀时，<code>!</code> 是 JavaScript 的逻辑非运算符。但作为后缀时，<code>!</code> 被解释为类型断言，表示该值非 <code>null</code>。这种写法比 <code>as</code> 更优，因为它让类型中的非空部分保持不变。</p><p>不过，你应该像对待任何其他断言一样谨慎使用 <code>!</code>：它会在编译时被移除，所以只有在你知道类型检查器无法获取的信息并且能够确保值非 <code>null</code> 时，才应该使用它。如果不能确保，你应该使用条件语句来检查是否为 <code>null</code>。</p><p>如果你正在访问一个可能为 <code>null</code> 的对象的属性或方法，使用“可选链”运算符 <code>?.</code> 会更加方便：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hi there!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/CYewxgrgtgpgdgFwHQHMYIKIBsa0QIQE8BJYACgHIAzEECgSgH4kBDYYDAN3gQBkBLAM4J4MAE6UwWfmADWFADQACMvSUBeAHxKA3gCglSljjEJKACX5KEAC3EwAhAwDcegL71XQA" target="_blank" rel="noreferrer">💻 playground</a></p><p>这看起来和 <code>!</code> 有些相似，但实际上差别很大。<code>a?.b</code> 是一个 JavaScript 构造，表示在运行时检查对象是否为 <code>null</code>（或 <code>undefined</code>），然后再继续计算表达式。而 <code>a!.b</code> 是一个类型级别的构造，编译后只会变成 <code>a.b</code>。如果对象在运行时是 <code>null</code>，它会抛出异常。<code>a?.b</code> 比 <code>a!.b</code> 更安全，但也不要过度使用。以上面代码为例，那么你可能希望事件监听器是否添加成功！</p><p>类型断言是有局限的：它们不能让你在任意类型之间转换。一般规则是，如果类型 A 和 B 之间是“可比较”的，你可以使用类型断言进行转换。用第 7 条中的集合术语来说，A 和 B 必须有非空交集。例如，<code>HTMLElement</code> 是 <code>HTMLElement | null</code> 的子类型，所以这种类型断言是可以的。（这两种类型的交集是 <code>HTMLElement</code>。）<code>HTMLButtonElement</code> 是 <code>EventTarget</code> 的子类型，所以这种类型断言也可以。而 <code>Person</code> 是 <code>{}</code> 的子类型，所以这种断言也是可以的。</p><p>但你不能在 <code>Person</code> 和 <code>HTMLElement</code> 之间进行转换，因为它们的交集是空的（即 <code>never</code> 类型）：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> body</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.body</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//         ~~~~~~~~~~~~~~</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Conversion of type &#39;HTMLElement&#39; to type &#39;Person&#39; may be a mistake because</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// neither type sufficiently overlaps with the other. If this was intentional,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// convert the expression to &#39;unknown&#39; first.</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN7IhwC2EAXMhmFKAOYDcyAvgFAI5XIBGWAJgJ7IAvMl5YEAV1LgAdDwH02HMMggAbYdz6C4GNJhyKA9EeRnz5gH7Wbt2yxPIAwjgBumYDmRYYyMPwAHFAByAAkAFQBZABkAUTUIaTBgvyw-QJD0KGwQFOI4QS4UOGRiYCo4AGsUIoQ4CQwIB1MQCGAwAAtodKDKCRgYYARgCHA1QSx3KDU4AL0Ad3aOvy7vTugZZABJX07y5HndZFBIcE8iNQAaZuR2ECmVddUADwCoCAwMc9TkYIkQSogLDzXLIQbZMAyFhAA" target="_blank" rel="noreferrer">💻 playground</a></p><p>这个错误提示了一个建议————期待使用 <code>unknown</code> 类型（见第 46 条）。每种类型都是 <code>unknown</code> 的子类型，所以涉及 <code>unknown</code> 的断言总是可以的。这让你可以在任意类型之间进行转换，但至少你明确表明了你正在做一些可疑的操作！</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.body </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> unknown</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // OK</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN7IhwC2EAXMhmFKAOYDcyAvgFAI5XIQA2yAvMgAmWBAFdS4AHQAjLIICeyOBmSiQAaxBYA7rmVpMORsgD0J5AHkA0iyA" target="_blank" rel="noreferrer">💻 playground</a></p><p>并不是每个类型断言都使用 <code>as</code> 关键字。第 22 条解释了“用户定义的类型保护”（<code>is</code>），它允许你在类型断言中关联一些逻辑来检查其有效性。也可以使用泛型类型推断来断言类型，但这并不是一个好主意，因为你很容易误以为 TypeScript 在检查类型，实际上并没有。这个模式（“只返回泛型”）在第 51 条中有详细讲解。</p><p>类型断言有时被称为“类型转换”。然而，这个术语是误导性的，最好避免使用。在像 C 这样的语言中，类型转换可以在运行时改变一个值（比如从 <code>int</code> 转换为 <code>float</code>）。而类型断言不能这样做。它们是类型级别的构造，在运行时会被移除，不会改变值。它们只是“断言”一些已经成立的事实。</p><p>最后，还有 <code>as const</code>。虽然这看起来像是类型断言，但更准确的说法是“常量上下文”。虽然 <code>as T</code> 会引起你的警惕，但 <code>as const</code> 会使类型更加精确，并且完全安全。第 24 条展示了如何使用常量上下文来改善类型推断。</p><h2 id="关键点总结" tabindex="-1">关键点总结 <a class="header-anchor" href="#关键点总结" aria-label="Permalink to &quot;关键点总结&quot;">​</a></h2><ul><li>优先使用类型注解（<code>: Type</code>），少用类型断言（<code>as Type</code>）。</li><li>熟悉如何为箭头函数标注返回类型。</li><li>只有在你确信自己比 TypeScript 更清楚类型情况时，才使用类型断言或非空断言。</li><li>使用类型断言时，务必加注释解释为什么这样写是安全的。</li></ul>`,67)]))}const E=i(e,[["render",p]]);export{o as __pageData,E as default};
