import{_ as i,c as a,o as t,ag as e}from"./chunks/framework.D53w8jfx.js";const o=JSON.parse('{"title":"第 80 条：使用 @ts-check 和 JSDoc 体验 TypeScript","description":"","frontmatter":{},"headers":[],"relativePath":"ch-migrate/jsdoc-tscheck.md","filePath":"ch-migrate/jsdoc-tscheck.md"}'),n={name:"ch-migrate/jsdoc-tscheck.md"};function p(l,s,h,k,r,d){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="第-80-条-使用-ts-check-和-jsdoc-体验-typescript" tabindex="-1">第 80 条：使用 <code>@ts-check</code> 和 JSDoc 体验 TypeScript <a class="header-anchor" href="#第-80-条-使用-ts-check-和-jsdoc-体验-typescript" aria-label="Permalink to &quot;第 80 条：使用 \`@ts-check\` 和 JSDoc 体验 TypeScript&quot;">​</a></h1><h2 id="要点" tabindex="-1">要点 <a class="header-anchor" href="#要点" aria-label="Permalink to &quot;要点&quot;">​</a></h2><ul><li>在 JavaScript 文件顶部添加 &quot;<code>// @ts-check</code>&quot; 以启用类型检查，而无需转换为 TypeScript。</li><li>识别常见错误。了解如何声明全局变量并为第三方库添加类型声明。</li><li>使用 JSDoc 注释进行类型断言和更好的类型推断。</li><li>不要花太多时间通过 JSDoc 让代码完美类型化。记住，目标是转换为 <em>.ts</em> 文件！</li></ul><h2 id="正文" tabindex="-1">正文 <a class="header-anchor" href="#正文" aria-label="Permalink to &quot;正文&quot;">​</a></h2><p>在将 JavaScript 文件正式转换为 TypeScript（第 81 条）之前，你可以先用<code>@ts-check</code>指令进行类型检查，提前发现潜在问题。这个指令会让 TypeScript 对单个文件进行宽松的类型分析（比关闭<code>noImplicitAny</code>的 TypeScript 更宽松）。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-check</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { first: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Grace&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, last: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hopper&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person.first</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//  ~~~~~~~~~~~~ The right-hand side of an arithmetic operation must be of type</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//               &#39;any&#39;, &#39;number&#39;, &#39;bigint&#39; or an enum type</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5&amp;allowJs=true&amp;noEmit=true#code/PTAEAEBcGcFoGMAWBTeBrAUPA9gO2pKAA7IBO0eoAvKAN4BmAluZAFygDkA4qQIbzIOAGlAAbXgXYcAEtiIlSHAL4BuDACZQAKmJkKuAHRMWGEKFAA-K9ZtXQAFRShSjAOaJIsRL1wATUNCMvsig2PSgPhEukIgAtsiQjPChCryJlLEArgSgAEYhYaCQAJ4kpmDmlVXVHD7Fwpy4mbH5iiIcuW6MuJAcoaQRuKDITbFFpcgYQA" target="_blank" rel="noreferrer">💻 playground</a></p><p>TypeScript 会自动推断 <code>person.first</code> 的类型是字符串，所以 <code>2 * person.first </code>会报类型错误，不需要手动加类型标注。</p><p>虽然它能发现这种明显的类型错误，或者函数调用时参数过多的情况，但实际上 <code>@ts-check</code> 通常只会揪出少数特定类型的错误。</p><h3 id="未声明的全局变量" tabindex="-1">未声明的全局变量 <a class="header-anchor" href="#未声明的全局变量" aria-label="Permalink to &quot;未声明的全局变量&quot;">​</a></h3><p>如果是你自己定义的符号，就用<code>let</code>或<code>const</code>声明它们。<br> 如果是&quot;环境&quot;符号（比如定义在 HTML 文件<code>&lt;script&gt;</code>标签里的），可以创建类型声明文件来描述它们。例如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-check</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user.firstName)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//          ~~~~ Cannot find name &#39;user&#39;</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5&amp;allowJs=true&amp;noEmit=true#code/PTAEAEBcGcFoGMAWBTeBrAUPA9gO2tgDbIB0h2A5gBQCu0yATiQGYCWD0kAcgIYC2yAJQBuDCFATJUgH6zpoAMI9cubJFBtcAE1C5+yUAHI6jQxiA" target="_blank" rel="noreferrer">💻 playground</a></p><p>那么你可以创建一个<code>types.d.ts</code>文件：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  firstName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  lastName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserData</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5&amp;allowJs=true&amp;noEmit=true#code/JYOwLgpgTgZghgYwgAgKoGdoBE5jsgbwChlkZgp0wA5OAWwgC5kqpQBzAbhOQBs4qtBs1YduAXyIATCAn5QUvCGGQBXTFGYZsuONyA" target="_blank" rel="noreferrer">💻 playground</a></p><p>可能需要调整<code>tsconfig.json</code>文件让 TypeScript 识别这个声明文件，这样错误就会消失。<br> 这个<code>types.d.ts</code>文件很有价值，因为它描述了代码运行的环境（见第 76 条），会成为项目类型声明的基础。</p><h3 id="未知的第三方库" tabindex="-1">未知的第三方库 <a class="header-anchor" href="#未知的第三方库" aria-label="Permalink to &quot;未知的第三方库&quot;">​</a></h3><p>如果你用第三方库（比如 jQuery 操作 HTML 元素），TypeScript 需要知道它的类型。否则开启<code>@ts-check</code>后会报错：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-check</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#graph&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ width: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;100px&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, height: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;100px&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Error: Cannot find name &#39;$&#39;</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5&amp;allowJs=true&amp;noEmit=true#code/PTAEAEBcGcFoGMAWBTeBrAUAEgBQHIBiAcwCcBDAB0TwEoA6aSATwBtkcBvPAdwEsATSNQBcoPAEYADJIoAPPABoxKXkUSQ8oidLl4AvjQDcGEKACiJEgHsSogMJkAdo6uRQAM16P+oR2QC2yGJYeBhAA" target="_blank" rel="noreferrer">💻 playground</a></p><p>解决方法是通过 npm 安装 jQuery 的类型声明：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --save-dev</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> @types/jquery</span></span></code></pre></div><p>现在错误明确指向 jQuery 了：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-check</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#graph&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ width: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;100px&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, height: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;100px&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//          ~~~~~ Property &#39;style&#39; does not exist on type &#39;JQuery&lt;HTMLElement&gt;&#39;</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5&amp;allowJs=true&amp;noEmit=true#code/PTAEAEBcGcFoGMAWBTeBrAUAEgBQHIBiAcwCcBDAB0TwEoA6aSATwBtkcBvPAdwEsATSNQBcoPAEYADJIoAPPABoxKXkUSQ8oidLl4AvjQDcGEKDPmLAP2vXQABRIB7CshLMxjVsjyh+j5NCgAHaOkKDIsryMoI5BoMwuYgBSAIoArq5MADwAEgAqALIAMgCibAC2yEGQAHx4GEA" target="_blank" rel="noreferrer">💻 playground</a></p><p>实际上应该用<code>.css</code>而不是<code>.style</code>。<br><code>@ts-check</code>让你无需迁移到 TypeScript 就能享受流行 JS 库的类型声明，这是使用它的最大优势。注意安装的库类型版本要和你实际使用的库版本匹配（第 66 条解释了版本不匹配的问题）。</p><h3 id="dom-相关问题" tabindex="-1">DOM 相关问题 <a class="header-anchor" href="#dom-相关问题" aria-label="Permalink to &quot;DOM 相关问题&quot;">​</a></h3><p>假设你写的是浏览器端代码，TypeScript 可能会标记 DOM 操作问题，例如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-check</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ageEl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;age&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ageEl.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;12&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ~~~~~ Property &#39;value&#39; does not exist on type &#39;HTMLElement&#39;</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5&amp;strictNullChecks=false&amp;allowJs=true&amp;noEmit=true#code/PTAEAEBcGcFoGMAWBTeBrAUPA9gO2pKAIYDmyAogDagC8oAJtvAK4C2yukAdGZFcu04AhAJ4BJegAoA5KWTSAlAG4McqlwBuRSs2S1Q0gIwAmaSpChLoAH63boAAoAnbAAdkTyCINad8htjI0KC42ITIAB4AlgSgeKBe7gYAEgAqALIAMvyCkNIYQA" target="_blank" rel="noreferrer">💻 playground</a></p><p>这是因为<code>getElementById</code>返回的是通用<code>HTMLElement</code>，而只有<code>HTMLInputElement</code>才有<code>value</code>属性（第 75 条详细说明了 DOM 类型处理）。</p><p>如果确定<code>#age</code>是输入框，可以用 JSDoc 做类型断言（注意括号不能少）：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-check</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ageEl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /** </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {HTMLInputElement}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;age&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ageEl.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;12&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // OK</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5&amp;strictNullChecks=false&amp;allowJs=true&amp;noEmit=true#code/PTAEAEBcGcFoGMAWBTeBrAUPA9gO2pKAIYDmyAogDagC8owAVAxJAJ4AOyoA3gBIAqAWQAyASVzsArpCrIAtslyQAvqAbAAFABNs8SQqUA6MjMrzFkAEKtRWjQHJSyewEoXAbgxOqhgG5FKSS46ewBGACZ7d1B6MAB5AGkMIA" target="_blank" rel="noreferrer">💻 playground</a></p><p>此时编辑器会识别<code>ageEl</code>为<code>HTMLInputElement</code>类型。这引出了<code>@ts-check</code>的另一个常见问题：不准确的 JSDoc 注释。</p><h3 id="不准确的-jsdoc-注释" tabindex="-1">不准确的 JSDoc 注释 <a class="header-anchor" href="#不准确的-jsdoc-注释" aria-label="Permalink to &quot;不准确的 JSDoc 注释&quot;">​</a></h3><p>如果你的项目已存在 JSDoc 风格的注释，开启<code>@ts-check</code>后 TypeScript 会开始检查它们。若你曾用 Closure Compiler 这类工具进行过类型检查，问题可能不大。但若之前的注释更像是&quot;理想型 JSDoc&quot;（即注释与实现不符），可能会遇到意外错误：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-check</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Gets the size (in pixels) of an element.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {Node}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> el</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> The element</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {{w: number, h: number}}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> The size</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">el</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bounds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> el.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getBoundingClientRect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //                ~~~~~~~~~~~~~~~~~~~~~</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //     Property &#39;getBoundingClientRect&#39; does not exist on type &#39;Node&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { width: bounds.width, height: bounds.height }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //      ~~~~~ Type &#39;{ width: any; height: any; }&#39; is not</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //            assignable to type &#39;{ w: number; h: number; }&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5&amp;strictNullChecks=false&amp;allowJs=true&amp;noEmit=true#code/PTAEAEBcGcFoGMAWBTeBrAUMAVNjptQBxZGUSFUaASwC9lQAKagO1AAdqAPZAG2gCUoAPYAzUAEM2fZAFtkLSADp8hcOwkAnCbNABvAHLCAJsgC+oPqAAqlGfMWqIm0gFdNbPXoDuALlAsrrIARsiaADSgiP6BIWFmFrYMNPSqwBiirizwkNTCbADmpADKdMiMfEJ6+KDw+dCQoMHCWcbQoAC8lrxKRZAAQi0sxqwFAMK81AqQAEqokIwCANw1IKDrG5tboAB+e-sHh0erYJsACprC7GGQAJ6gAOR9g62jE1OKczkPoMbCyO0WMJGsguNQGiI2Hdro8jKYHjUXJB3J5vNRjBR-M1WtAlGiMYhIihqAVEJAsUM2kpiaTIGYVus1ltDjZbjCHnpQPjMZIWLcllFkCSyf4pPzQGYfuCAsCTttthJoDQCiwJMFeAxIMJyGyGByuTEgqFNALogEjWEBZKMGYMEA" target="_blank" rel="noreferrer">💻 playground</a></p><p>第一个问题是误解了 DOM：<code>getBoundingClientRect()</code>是定义在 Element 上的，不是 Node。所以应该更新<code>@param</code>标签。第二个问题是<code>@return</code>标签中指定的属性与实际实现不匹配。推测项目其他部分都使用<code>width</code>和<code>height</code>属性，因此应该更新<code>@return</code>标签。其实这个标签甚至可以去掉，因为 TypeScript 能自动推断返回类型。</p><p>你可以用 JSDoc 逐步给项目添加类型标注。TypeScript 语言服务会提供&quot;推断类型标注&quot;的快速修复功能，适用于那些从代码用法就能明确类型的场景。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>你会在编辑器里看到 <code>val</code> 下方出现虚线标注，点击它就能看到如图 10-2 所示的快速修复选项。</p><p><img src="https://cdn.jsdelivr.net/gh/rayadaschn/blogImage@master/img/202506102225524.png" alt="Figure 10-2. The TypeScript Language Services offer a quick fix to infer parameter types from usage."></p><p>这会生成正确的 JSDoc 注释：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-check</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5&amp;strictNullChecks=false&amp;allowJs=true&amp;noEmit=true#code/PTAEAEBcGcFoGMAWBTeBrAUMAVNjpsIAHAQwCcSBbUAbwDsBXSgI2TIF9QA3EgG32zAMAMwZ14kAJYB7OqAAm0hs17IAFD14BKWvlBlkkBmTkAmAtz4BuDOwxA" target="_blank" rel="noreferrer">💻 playground</a></p><p>使用<code>@ts-check</code>有助于推动类型在代码中转换。但效果并不总是理想，例如：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  data.files.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">file</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5&amp;strictNullChecks=false&amp;allowJs=true&amp;noEmit=true&amp;noImplicitAny=false#code/GYVwdgxgLglg9mABAGzgQwCYBE1TQCg1zQEpEBvAKEUSLwDpgZkBTAZ0bgCcBRNCABb40bAJ6RETVogC8APgrUaiAPQrE9TUoC+JANyVtlIA" target="_blank" rel="noreferrer">💻 playground</a></p><p>如果使用快速修复功能来标注 data 类型，最终会得到：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> *  files: { forEach: (arg0: (file: any) =&gt; Promise&lt;void&gt;) =&gt; void; };</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> * }}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5&amp;strictNullChecks=false&amp;allowJs=true&amp;noEmit=true&amp;noImplicitAny=false#code/PQKhCgAIUgBAHAhgJ0QW0gb01GkBmAlgDYCmAzgFxYED2yAoogMYAW1AFCgOYAMnRMtUQA7AJ4BKSAF4AfJAAKyWmkLlSAHgButQgBNZUuZB36A3JAC+Z3FcuQ9iAC6JcwcPgCuI5k8K0RSGJaRD0AEWdEDkcXKRxISGBgSAA6NPBLcCA" target="_blank" rel="noreferrer">💻 playground</a></p><p>这里出现了结构类型化的误用（第 4 条）。虽然从技术上讲该函数能处理任何具有特定签名的 forEach 方法的对象，但实际意图很可能是要求参数类型为 <code>{files: string[]}</code>。</p><p>通过 JSDoc 注释和<code>@ts-check</code>，你可以在 JavaScript 项目中获得大部分 TypeScript 的体验。这种方式很吸引人，因为它不需要改变你的工具链。但最好不要过度依赖这种方法——注释模板会带来额外的成本：你的业务逻辑很容易淹没在 JSDoc 的海洋里。TypeScript 在<code>.ts</code> 文件中才能发挥最佳效果，而不是<code>.js</code> 文件。最终目标应该是将项目转换为 TypeScript，而不是停留在带 JSDoc 注释的 JavaScript 阶段。</p><p><code>@ts-check</code>的真正价值在于组织层面：在向管理层申请投入数周或数月进行 TypeScript 迁移之前，它可以作为实验类型系统、发现迁移障碍、评估迁移难度的有效工具。</p><h2 id="关键点总结" tabindex="-1">关键点总结 <a class="header-anchor" href="#关键点总结" aria-label="Permalink to &quot;关键点总结&quot;">​</a></h2><ul><li>在 JavaScript 文件顶部添加 &quot;<code>// @ts-check</code>&quot; 以启用类型检查，而无需转换为 TypeScript。</li><li>识别常见错误。了解如何声明全局变量并为第三方库添加类型声明。</li><li>使用 JSDoc 注释进行类型断言和更好的类型推断。</li><li>不要花太多时间通过 JSDoc 让代码完美类型化。记住，目标是转换为 <em>.ts</em> 文件！</li></ul>`,59)]))}const g=i(n,[["render",p]]);export{o as __pageData,g as default};
