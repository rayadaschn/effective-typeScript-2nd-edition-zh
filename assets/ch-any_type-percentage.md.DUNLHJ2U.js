import{_ as a,c as i,o as e,ag as n}from"./chunks/framework.D53w8jfx.js";const r=JSON.parse('{"title":"第 49 条: 跟踪你的类型覆盖率以防止类型安全性回归","description":"","frontmatter":{},"headers":[],"relativePath":"ch-any/type-percentage.md","filePath":"ch-any/type-percentage.md"}'),t={name:"ch-any/type-percentage.md"};function p(l,s,d,o,h,c){return e(),i("div",null,s[0]||(s[0]=[n(`<h1 id="第-49-条-跟踪你的类型覆盖率以防止类型安全性回归" tabindex="-1">第 49 条: 跟踪你的类型覆盖率以防止类型安全性回归 <a class="header-anchor" href="#第-49-条-跟踪你的类型覆盖率以防止类型安全性回归" aria-label="Permalink to &quot;第 49 条: 跟踪你的类型覆盖率以防止类型安全性回归&quot;">​</a></h1><h2 id="要点" tabindex="-1">要点 <a class="header-anchor" href="#要点" aria-label="Permalink to &quot;要点&quot;">​</a></h2><ul><li>即使设置了 <code>noImplicitAny</code>，<code>any</code> 类型仍然可能通过显式的 <code>any</code> 或第三方类型声明（<code>@types</code>）进入你的代码中。</li><li>考虑使用诸如 <code>type-coverage</code> 之类的工具来跟踪你的程序的类型覆盖情况。这将鼓励你重新审视使用 <code>any</code> 的决策，并随着时间的推移提高类型安全性。</li></ul><h2 id="正文" tabindex="-1">正文 <a class="header-anchor" href="#正文" aria-label="Permalink to &quot;正文&quot;">​</a></h2><p>你已经启用了 <code>noImplicitAny</code> 并为所有具有隐式 <code>any</code> 类型的值添加了类型注解。你是否已经免受与 <code>any</code> 类型相关的问题？答案是&quot;不&quot;；<code>any</code> 类型仍然可以通过两种主要方式进入你的程序：</p><h3 id="通过显式的-any-类型" tabindex="-1">通过显式的 any 类型 <a class="header-anchor" href="#通过显式的-any-类型" aria-label="Permalink to &quot;通过显式的 any 类型&quot;">​</a></h3><p>即使你遵循了第 43 和 44 条的建议，使你的 <code>any</code> 类型既狭窄又具体，它们仍然是 <code>any</code> 类型。特别是，像 <code>any[]</code> 和 <code>{[key: string]: any}</code> 这样的类型一旦你索引到它们，就会变成普通的 <code>any</code>，并且产生的 <code>any</code> 类型可以在你的代码中流动。</p><h3 id="来自第三方类型声明" tabindex="-1">来自第三方类型声明 <a class="header-anchor" href="#来自第三方类型声明" aria-label="Permalink to &quot;来自第三方类型声明&quot;">​</a></h3><p>这特别阴险，因为来自 <code>@types</code> 声明文件的 <code>any</code> 类型会静默进入：即使你启用了 <code>noImplicitAny</code> 并且从未写过&quot;any&quot;这个词，你仍然有 <code>any</code> 类型在你的代码中流动。</p><p>由于 <code>any</code> 类型对类型安全性和开发者体验的负面影响（第 5 条），跟踪代码库中它们的数量是一个好主意。有很多方法可以做到这一点，包括 npm 上的 <code>type-coverage</code> 包：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> type-coverage</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">9985</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10117</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 98.69%</span></span></code></pre></div><p>这意味着，在这个项目的 10,117 个符号中，9,985 个（98.69%）具有除 <code>any</code> 或 <code>any</code> 别名之外的类型。如果一个更改无意中引入了 <code>any</code> 类型并且它在你的代码中流动，你会看到这个百分比的相应下降。</p><p>从某种意义上说，这个百分比是跟踪你遵循本章其他建议程度的一种方式。使用范围狭窄的 <code>any</code> 将减少具有 <code>any</code> 类型的符号数量，使用更具体的形式如 <code>any[]</code> 也是如此。数字化跟踪这一点有助于你确保事情只会随着时间的推移变得更好。</p><p>即使只收集一次类型覆盖率信息也可能是有益的。使用 <code>--detail</code> 标志运行 <code>type-coverage</code> 将打印每个 <code>any</code> 类型在代码中出现的位置：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> type-coverage</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --detail</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">path/to/code.ts:1:10</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> getColumnInfo</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">path/to/module.ts:7:1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pt2</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span></code></pre></div><p>这些值得调查，因为它们可能会发现你之前没有考虑过的 <code>any</code> 来源。让我们看几个例子。</p><p>显式的 <code>any</code> 类型通常是你之前为了便利而做出的选择的结果。也许你遇到了一个你不想花时间解决的类型错误。也许这个类型是你还没有写出来的。或者你可能只是太匆忙了。</p><p>带有 <code>any</code> 的类型断言可以防止类型流向它们本来会流向的地方。也许你构建了一个处理表格数据的应用程序，需要一个单参数函数来构建某种列描述：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getColumnInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> utils.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">buildColumnInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(appState.dataSchema, name) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Returns any</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/MYewdgzgLgBArlAlgGwjAvDA3gKBjAIzhQBMBhEZOAWzAEkwAzEACggC4YBDMATwBoYYLtQCmnaACdEYAOYBKTj17YAvvxyqA3DhKjgyLpNExko2FwAOlgMpQuUcdhgkHXG8AAWo6l05wwAGswEAB3MBhtHEYA4CRwGFlzCipaBmYWYTEJKGk5RW4+bDwYYyg4SQiEFAgAOiJSFJp6JlYrW3tHWtd7D29fQSzReS18AHoxmAAlcwrIQt5NHCA" target="_blank" rel="noreferrer">💻 playground</a></p><p><code>utils.buildColumnInfo</code> 函数在某个时候返回了 <code>any</code>。作为提醒，你为函数添加了注释和显式的 <code>: any</code> 注解。</p><p>然而，在接下来的几个月中，你也为 <code>ColumnInfo</code> 添加了类型，并且 <code>utils.buildColumnInfo</code> 不再返回 <code>any</code>。<code>any</code> 注解现在正在丢弃有价值的类型信息。摆脱它！</p><p>第三方的 <code>any</code> 类型可能以几种形式出现，但最极端的是当你给整个模块一个 <code>any</code> 类型时：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;my-module&#39;</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/MYewdgzgLgBArlAlgGwjAvDA3gKBjAIzhQBMBhEZOAWzAEkwAzEACggC4YBDMATwBoYYLtQCmnaACdEYAOYBKTj17YAvvxyqA3DhKjgyLpNExko2FwAOlgMpQuUcdhgkHXG8AAWo6l05wwAGswEAB3MBhtXX1DYxhqEBI4MxgAcmpeAFoEpLNUnSA" target="_blank" rel="noreferrer">💻 playground</a></p><p>现在你可以从 <code>my-module</code> 导入任何东西而不会出错。这些符号都有 <code>any</code> 类型，如果你通过它们传递值，将导致更多的 <code>any</code> 类型：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { someMethod, someSymbol } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;my-module&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // OK</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pt1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { x: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, y: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ^? const pt1: { x: number; y: number; }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pt2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pt1, someSymbol) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ^? const pt2: any</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5#code/MYewdgzgLgBArlAlgGwjAvDA3gKBjAIzhQBMBhEZOAWzAEkwAzEACggC4YBDMATwBoYYLtQCmnaACdEYAOYBKTj17YAvvxyqA3DhKjgyLpNExko2FwAOlgMpQuUcdhgkHXG8AAWo6l05wwAGswEAB3MBhtHERqSxBJWCwIEDEAWXNPEBJBZLEbXmoCSlUYRkkUmAByal4AWmosuDNKrXwAejaYAHkAaRwcUEhYSygARgxnAA9OUcFeTgAmSJ0O-HwAPQB+GEHoGBHRziwYaaEaAlFJVvmzwsvW1QHwPZGlzFzRdKhMkhYDnJSonyhUo8laMFWvRwqzWWx2z2GUAWSj4OCAA" target="_blank" rel="noreferrer">💻 playground</a></p><p>由于使用方式看起来与类型良好的模块相同，很容易忘记你存根化了模块。或者也许同事做了这件事，而你一开始就不知道。值得不时重新审视这些。也许模块有官方的类型声明。或者也许在阅读第 8 章之后，你已经对模块有了足够的理解，可以自己编写类型并将它们贡献回社区。</p><p>第三方声明的 <code>any</code> 的另一个常见来源是类型中存在错误。也许声明没有遵循第 30 条的建议，声明一个函数返回联合类型，而实际上它返回的东西要具体得多。当你第一次使用这个函数时，这似乎不值得修复，所以你使用了 <code>any</code> 断言。但也许声明从那以后已经被修复了。或者也许是时候自己修复它们了！</p><p>如果你想持续了解代码中的 <code>any</code> 类型，可以将 <code>type-coverage</code> 设置为 TypeScript 语言服务插件。这就像拥有 X 射线视觉，让你看到代码中隐藏的所有 <code>any</code> 类型（图 5-1）。</p><p><img src="https://cdn.jsdelivr.net/gh/rayadaschn/blogImage@master/img/202506221431668.png" alt="图 5-1. 在编辑器中高亮显示具有 any 类型的符号。这些都不会是 noImplicitAny 错误。"></p><p>如果你将 <code>type-coverage</code> 添加到你的持续集成系统中，你会在类型安全性意外下降时立即发现。</p><p>导致你使用 <code>any</code> 类型的考虑可能不再适用。也许现在有一个类型可以插入，而你之前使用了 <code>any</code>。也许不安全的类型断言不再必要。也许你一直在回避的类型声明中的错误已经被修复了。跟踪你的类型覆盖率突出了这些选择，并鼓励你继续重新审视它们。</p><h2 id="要点回顾" tabindex="-1">要点回顾 <a class="header-anchor" href="#要点回顾" aria-label="Permalink to &quot;要点回顾&quot;">​</a></h2><ul><li>即使设置了 <code>noImplicitAny</code>，<code>any</code> 类型仍然可能通过显式的 <code>any</code> 或第三方类型声明（<code>@types</code>）进入你的代码中。</li><li>考虑使用诸如 <code>type-coverage</code> 之类的工具来跟踪你的程序的类型覆盖情况。这将鼓励你重新审视使用 <code>any</code> 的决策，并随着时间的推移提高类型安全性。</li></ul>`,36)]))}const y=a(t,[["render",p]]);export{r as __pageData,y as default};
