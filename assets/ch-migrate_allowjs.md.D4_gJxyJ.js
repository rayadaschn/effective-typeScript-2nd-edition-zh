import{_ as i,c as a,o as t,ag as e}from"./chunks/framework.D53w8jfx.js";const c=JSON.parse('{"title":"第 81 条: 使用 allowJs 混合使用 TypeScript 和 JavaScript","description":"","frontmatter":{},"headers":[],"relativePath":"ch-migrate/allowjs.md","filePath":"ch-migrate/allowjs.md"}'),l={name:"ch-migrate/allowjs.md"};function p(h,s,n,k,d,r){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="第-81-条-使用-allowjs-混合使用-typescript-和-javascript" tabindex="-1">第 81 条: 使用 <code>allowJs</code> 混合使用 TypeScript 和 JavaScript <a class="header-anchor" href="#第-81-条-使用-allowjs-混合使用-typescript-和-javascript" aria-label="Permalink to &quot;第 81 条: 使用 \`allowJs\` 混合使用 TypeScript 和 JavaScript&quot;">​</a></h1><h2 id="要点" tabindex="-1">要点 <a class="header-anchor" href="#要点" aria-label="Permalink to &quot;要点&quot;">​</a></h2><ul><li>使用 <code>allowJs</code> 编译选项来支持在过渡项目时混合使用 JavaScript 和 TypeScript。</li><li>在开始大规模迁移之前，先确保你的测试和构建链与 TypeScript 一起正常工作。</li></ul><h2 id="正文" tabindex="-1">正文 <a class="header-anchor" href="#正文" aria-label="Permalink to &quot;正文&quot;">​</a></h2><p>对于小项目，你可以一次性从 JavaScript 切换到 TypeScript。但对于大项目，这种&quot;暂停一切&quot;的方式行不通。你需要逐步过渡，这意味着要让 TypeScript 和 JavaScript 共存。</p><p>关键就是 <code>allowJs</code> 编译器选项。开启后，TS 和 JS 文件可以互相导入。对 JS 文件该模式极其宽松——除非使用<code>@ts-check</code>（第 80 条），否则只会报语法错误。这是最浅层的&quot;TS 是 JS 超集&quot;的体现。</p><p>虽然 <code>allowJs</code> 不太能发现错误，但它让你能在修改代码前先把 TS 引入构建流程。这很有用，因为如第 82 条所述，在转换单个模块为 TS 时你需要能运行测试。</p><p>如果你的打包工具支持 TS 或有插件（比如 webpack 安装 <code>ts-loader</code>）：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --save-dev</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ts-loader</span></span></code></pre></div><p>然后在 webpack.config.js 配置：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  module: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rules: [{ test:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">tsx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, use: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ts-loader&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, exclude:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">node_modules</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>多数测试工具也有类似方案。比如 Jest 安装 <code>ts-jest</code> 后，在 <code>jest.config.js</code> 配置：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  transform: { </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;^.+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.tsx?$&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ts-jest&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>如果是 Node.js 环境，最简单是用 ts-node：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ts-node/register</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main.ts</span></span></code></pre></div><p>自定义构建流程会更复杂，但有备用方案：设置 <code>outDir</code> 选项，然后 TS 会生成纯 JS 代码，原有构建流程通常能直接处理。你可能需要调整 <code>target</code> 和 <code>module</code> 等选项使输出贴近原 JS 代码。</p><p>虽然配置构建和测试流程不太有趣，但这是安全迁移代码的基础（下条会详述）。</p><h2 id="关键点总结" tabindex="-1">关键点总结 <a class="header-anchor" href="#关键点总结" aria-label="Permalink to &quot;关键点总结&quot;">​</a></h2><ul><li>使用 <code>allowJs</code> 编译选项来支持在过渡项目时混合使用 JavaScript 和 TypeScript。</li><li>在开始大规模迁移之前，先确保你的测试和构建链与 TypeScript 一起正常工作。</li></ul>`,19)]))}const g=i(l,[["render",p]]);export{c as __pageData,g as default};
