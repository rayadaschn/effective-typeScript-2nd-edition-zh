import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.D53w8jfx.js";const o=JSON.parse('{"title":"第 83 条：迁移完成的标志是启用 noImplicitAny","description":"","frontmatter":{},"headers":[],"relativePath":"ch-migrate/start-loose.md","filePath":"ch-migrate/start-loose.md"}'),p={name:"ch-migrate/start-loose.md"};function l(e,s,h,k,r,c){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="第-83-条-迁移完成的标志是启用-noimplicitany" tabindex="-1">第 83 条：迁移完成的标志是启用 <code>noImplicitAny</code> <a class="header-anchor" href="#第-83-条-迁移完成的标志是启用-noimplicitany" aria-label="Permalink to &quot;第 83 条：迁移完成的标志是启用 \`noImplicitAny\`&quot;">​</a></h1><h2 id="要点" tabindex="-1">要点 <a class="header-anchor" href="#要点" aria-label="Permalink to &quot;要点&quot;">​</a></h2><ul><li>没有开启 <code>noImplicitAny</code>，就不能算是真正完成 TypeScript 的迁移。宽松的类型检查可能会让真实的问题被掩盖。</li><li>可以循序渐进地修复类型错误，别急着强制要求。让团队有时间适应 TypeScript，再考虑更严格的校验选项。</li></ul><h2 id="正文" tabindex="-1">正文 <a class="header-anchor" href="#正文" aria-label="Permalink to &quot;正文&quot;">​</a></h2><p>把整个项目转换成 <code>.ts</code> 格式当然是一项很大的成就，但这并不代表你的工作已经结束。接下来的目标是启用 <code>noImplicitAny</code> 选项。没有启用 <code>noImplicitAny</code> 的 TypeScript 代码，其实处于“过渡期”，因为它可能会掩盖你在类型声明中犯下的错误。</p><p>比如，你可能用过“添加所有缺失成员”的快捷修复功能，像第 82 条提到的那样给类添加了属性声明，结果自动加上了 <code>any</code> 类型，然后你打算手动改成正确的：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Chart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  indices</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5&amp;noImplicitAny=false&amp;strictNullChecks=false#code/MYGwhgzhAEDCAWYBOAXaBvAUNaBLAdgCa7ACmEAXNGPgJ4Dcm20A9C9AHReYC+mQA" target="_blank" rel="noreferrer">💻 playground</a></p><p>你觉得 <code>indices</code> 应该是数字数组，就改成了：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Chart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  indices</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5&amp;noImplicitAny=false&amp;strictNullChecks=false#code/MYGwhgzhAEDCAWYBOAXaBvAUNaBLAdgCa7ACmEAXNPgK4C2ARqUgNoC6A3JttAPS-QAdMMwBfTEA" target="_blank" rel="noreferrer">💻 playground</a></p><p>改完没有报错，于是你就继续开发了。但其实你弄错了类型：<code>number[]</code> 并不对。来看一下类中其他地方的代码：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRanges</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> of</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.indices) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> low</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //    ^? const low: any</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> high</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //    ^? const high: any</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5&amp;noImplicitAny=false&amp;strictNullChecks=false#code/PTAEAkEkBEFECgDGAbAhgZ3aAwgC1QE4AuoA3vKKAJYB2AJlYgKboBcoNArgLYBGTBANoBdANzwQoWADlo8AOZMiAJVQ1F6ABQBKMhVAAzAPYFQmxEZroSpowdBFcVdADpaDZul3lKlC1ZJkIwB3UABeUCEABjF9SklfAD0AflB-a1Ag4PY1AE84tMsMp3lccMjBAEZY31AEyhTCgNAS3ByafNrJFx79AF94AckoOEGJMBk5IA" target="_blank" rel="noreferrer">💻 playground</a></p><p>很明显，<code>indices</code> 应该是一个二维数组 <code>number[][]</code>，或者是形如 <code>[number, number][]</code> 的数组才对。你可能会惊讶：为啥访问 <code>r[0]</code> 不报错？这正是没开 <code>noImplicitAny</code> 时，TypeScript 太宽松的体现。</p><p>如果你打开 <code>noImplicitAny</code>，这段代码就会报错了：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRanges</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> of</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.indices) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> low</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //          ~~~~ Element implicitly has an &#39;any&#39; type because</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //               type &#39;Number&#39; has no index signature</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> high</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //           ~~~~ Element implicitly has an &#39;any&#39; type because</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //                type &#39;Number&#39; has no index signature</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://www.typescriptlang.org/play/?ts=5.4.5&amp;noImplicitAny=true&amp;strictNullChecks=false#code/PTAEAkEkBEFECgDGAbAhgZ3aAwgC1QE4AuoA3vKKAJYB2AJlYgKboBcoNArgLYBGTBANoBdANzwQoWADlo8AOZMiAJVQ1F6ABQBKMhVAAzAPYFQmxEZroSpowdBFcVdADpaDZul3lKlC1ZJkIwB3UABeUCEABjF9SklfRMoAP1TkqWQmbiYaEipuAAdkRioiZABPUHwsNVAAcjVyuodygqZQfkRUTnQmONAEpKHKIlb2uukefgJm6o4janomAA9QdCp5GlQiTgI+xP9rKo3ccMjBAEZYxMHh0DT02Ezs3OpC4sRSiqqMUFqGmhNFptDpMLo9fa+W53RKjEETKYCWa-GgLdwrNYbLY7Pb9SQuAn6AC+8BJkigcFJEjAMjkQA" target="_blank" rel="noreferrer">💻 playground</a></p><p><strong>启用 <code>noImplicitAny</code> 的好策略</strong> 是先在本地配置里打开它，然后一点点修复这些错误。报错的数量也可以作为你迁移进度的参考。你也可以结合第 49 条的方法，通过类型覆盖率来衡量进展。</p><p>每次改动后都运行测试，并频繁提交，因为有些错误你可能要到后面才发现。另外也可以参考第 82 条的建议，沿着调用链“自底向上”地去修复类型。你也可以先修好类型，再等全部搞定后，再把 <code>tsconfig.json</code> 里的配置也提交上去。</p><p>你还可以有选择地优先修复关键代码中的 <code>noImplicitAny</code> 错误，比如先改生产环境代码，再处理测试代码。如果你的项目用到了项目引用（见第 78 条），甚至可以为不同部分配置不同的严格模式。</p><p>当然，还有很多其他选项可以进一步提高类型检查的严格性，比如开启 <code>&quot;strict&quot;: true</code>，但其中最重要的就是 <code>noImplicitAny</code>。即使你不启用其他严格设置，仅仅开启 <code>noImplicitAny</code>，TypeScript 就已经能带来很大帮助了。建议等团队对 TypeScript 更熟悉后，再逐步开启更严格的校验。</p><h2 id="关键点总结" tabindex="-1">关键点总结 <a class="header-anchor" href="#关键点总结" aria-label="Permalink to &quot;关键点总结&quot;">​</a></h2><ul><li>没有开启 <code>noImplicitAny</code>，就不能算是真正完成 TypeScript 的迁移。宽松的类型检查可能会让真实的问题被掩盖。</li><li>可以循序渐进地修复类型错误，别急着强制要求。让团队有时间适应 TypeScript，再考虑更严格的校验选项。</li></ul>`,24)]))}const g=i(p,[["render",l]]);export{o as __pageData,g as default};
