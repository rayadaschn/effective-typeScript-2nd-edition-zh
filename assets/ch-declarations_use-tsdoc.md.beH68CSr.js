import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.D53w8jfx.js";const c=JSON.parse('{"title":"Item 68: Use TSDoc for API Comments","description":"","frontmatter":{},"headers":[],"relativePath":"ch-declarations/use-tsdoc.md","filePath":"ch-declarations/use-tsdoc.md"}'),e={name:"ch-declarations/use-tsdoc.md"};function p(l,s,h,k,r,d){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="item-68-use-tsdoc-for-api-comments" tabindex="-1">Item 68: Use TSDoc for API Comments <a class="header-anchor" href="#item-68-use-tsdoc-for-api-comments" aria-label="Permalink to &quot;Item 68: Use TSDoc for API Comments&quot;">​</a></h1><h2 id="要点" tabindex="-1">要点 <a class="header-anchor" href="#要点" aria-label="Permalink to &quot;要点&quot;">​</a></h2><ul><li>使用 JSDoc/TSDoc 格式的注释来记录导出的函数、类和类型。这有助于编辑器在最相关时为用户提供信息。</li><li>使用 <code>@param</code>、<code>@returns</code> 和 Markdown 来进行格式化。</li><li>避免在文档中包含类型信息（参见第 31 条）。</li><li>使用 <code>@deprecated</code> 标记已废弃的 API。</li></ul><h2 id="正文" tabindex="-1">正文 <a class="header-anchor" href="#正文" aria-label="Permalink to &quot;正文&quot;">​</a></h2><p>下面是一个用于生成问候语的 TypeScript 函数：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Generate a greeting. Result is formatted for display.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">title</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Hello \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">title</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>作者贴心地为这个函数写了注释，描述了它的作用。但如果你希望为函数的使用者编写文档，最好使用 JSDoc 风格的注释：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/** Generate a greeting. Result is formatted for display. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greetJSDoc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">title</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Hello \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">title</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>原因在于，几乎所有编辑器都会在调用函数时显示 JSDoc 风格的注释（见下图 8-1）。</p><p><img src="https://cdn.jsdelivr.net/gh/rayadaschn/blogImage@master/img/202506221501248.png" alt="图 8-1. JSDoc 风格的注释会在编辑器的工具提示中显示。"></p><p>相比之下，内联注释则不会被这样处理（见下图 8-2）。</p><p><img src="https://cdn.jsdelivr.net/gh/rayadaschn/blogImage@master/img/202506221502421.png" alt="图 8-2. 内联注释通常不会在工具提示中显示。"></p><p>TypeScript 语言服务支持这种约定，你应该充分利用它。如果注释描述的是公共 API，就应该使用 JSDoc。在 TypeScript 语境下，这类注释有时也被称为 TSDoc。你可以使用许多常见的标签，比如 @param 和 @returns：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Generate a greeting.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> Name of the person to greet</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> title</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> The person&#39;s title</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@returns</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> A greeting formatted for human consumption.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greetFullTSDoc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">title</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Hello \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">title</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这样，编辑器在你编写函数调用时会显示每个参数的相关文档（如图 8-3 所示）。这里仅显示了 name 参数的文档，而不是 title。</p><p><img src="https://cdn.jsdelivr.net/gh/rayadaschn/blogImage@master/img/202506221503806.png" alt="图 8-3. @param 注解让编辑器在你输入参数时显示对应文档。"></p><p>你也可以在类型定义中使用 TSDoc：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/** A measurement performed at a time and place. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Measurement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /** Where was the measurement made? */</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  position</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vector3D</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /** When was the measurement made? In seconds since epoch. */</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  time</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /** Observed momentum */</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  momentum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vector3D</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>当你查看 Measurement 对象的各个字段时，会获得上下文相关的文档（见图 8-4）。</p><p><img src="https://cdn.jsdelivr.net/gh/rayadaschn/blogImage@master/img/202506221503310.png" alt="图 8-4. 字段的 TSDoc 会在鼠标悬停时显示。"></p><p>只要类型是&quot;同态&quot;的（参见第 15 项），字段上的文档就会通过映射类型（如 Partial 和 Pick 等辅助类型）被保留下来。</p><p>你可以用 @template 标签为泛型类型的类型参数编写文档。第 50 项会详细介绍其用法。</p><p>TSDoc 注释支持 Markdown 格式，因此你可以使用粗体、斜体或项目符号列表等格式（见图 8-5）。</p><p><img src="https://cdn.jsdelivr.net/gh/rayadaschn/blogImage@master/img/202506221504601.png" alt="图 8-5. TSDoc 注释可以包含 Markdown 格式。"></p><p>不过，尽量避免在文档中写&quot;长篇大论&quot;。最好的注释应简明扼要、直击要点。</p><p>JSDoc 包含一些用于指定类型信息的约定（如 @param {string} name ...），但你应避免这样做，而应优先使用 TypeScript 类型（参见第 31 项）。</p><p>最后，你应使用 @deprecated 标签标记已废弃的符号。这不仅能清楚地表明某个函数已废弃，还能启用 TSDoc 最强大的特性之一：被 @deprecated 标记的符号通常会以删除线形式显示。这样你甚至无需查看符号详情就能知道它已废弃，如图 8-6 所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rayadaschn/blogImage@master/img/202506221504495.png" alt="图 8-6. 被 @deprecated 标记的符号会显示删除线。"></p><p>如果你标记了某个方法为废弃，请务必告知用户新的替代方案。至少应在文档中给出相关参考。</p><h2 id="要点回顾" tabindex="-1">要点回顾 <a class="header-anchor" href="#要点回顾" aria-label="Permalink to &quot;要点回顾&quot;">​</a></h2><ul><li>使用 JSDoc/TSDoc 格式的注释来记录导出的函数、类和类型。这有助于编辑器在最相关时为用户提供信息。</li><li>使用 <code>@param</code>、<code>@returns</code> 和 Markdown 来进行格式化。</li><li>避免在文档中包含类型信息（参见第 31 条）。</li><li>使用 <code>@deprecated</code> 标记已废弃的 API。</li></ul>`,31)]))}const o=i(e,[["render",p]]);export{c as __pageData,o as default};
