import{_ as s,c as i,o as a,ag as p}from"./chunks/framework.D53w8jfx.js";const o=JSON.parse('{"title":"Item 65: Put TypeScript and @types in devDependencies","description":"","frontmatter":{},"headers":[],"relativePath":"ch-declarations/dev-dependencies.md","filePath":"ch-declarations/dev-dependencies.md"}'),n={name:"ch-declarations/dev-dependencies.md"};function t(d,e,l,c,h,r){return a(),i("div",null,e[0]||(e[0]=[p(`<h1 id="item-65-put-typescript-and-types-in-devdependencies" tabindex="-1">Item 65: Put TypeScript and @types in devDependencies <a class="header-anchor" href="#item-65-put-typescript-and-types-in-devdependencies" aria-label="Permalink to &quot;Item 65: Put TypeScript and @types in devDependencies&quot;">​</a></h1><p>Node Package Manager (npm) 在 JavaScript 世界中无处不在。它既提供了 JavaScript 库的仓库（npm 注册表），也提供了一种指定你依赖的版本的方式（package.json）。</p><p>npm 区分了几种类型的依赖，每种都放在 package.json 的不同部分：</p><h2 id="dependencies" tabindex="-1">dependencies <a class="header-anchor" href="#dependencies" aria-label="Permalink to &quot;dependencies&quot;">​</a></h2><p>这些是运行你的 JavaScript 所需的包。如果你在运行时导入 lodash，那么它应该放在 dependencies 中。当你将代码发布到 npm 上，其他用户安装它时，也会安装这些依赖。（这些被称为传递依赖。）</p><h2 id="devdependencies" tabindex="-1">devDependencies <a class="header-anchor" href="#devdependencies" aria-label="Permalink to &quot;devDependencies&quot;">​</a></h2><p>这些包用于开发和测试你的代码，但在运行时不需要。你的测试框架就是 devDependency 的一个例子。与 dependencies 不同，这些不会随你的包一起传递安装。</p><h2 id="peerdependencies" tabindex="-1">peerDependencies <a class="header-anchor" href="#peerdependencies" aria-label="Permalink to &quot;peerDependencies&quot;">​</a></h2><p>这些是你在运行时需要但不想负责跟踪的包。例如，如果你发布一个 React 组件，它将与 React 本身的一系列版本兼容。你更希望用户选择一个版本，而不是你为他们选择，这可能导致同一页面上运行多个版本的 React。</p><p>其中，dependencies 和 devDependencies 是最常见的。当你使用 TypeScript 时，要注意你添加的是哪种类型的依赖。因为 TypeScript 是一个开发工具，而 TypeScript 类型在运行时不存在（Item 3），所以与 TypeScript 相关的包通常属于 devDependencies。</p><p>第一个要考虑的依赖是 TypeScript 本身。虽然你可以全局安装 TypeScript，但这样做有两个主要原因是不好的：</p><ul><li>无法保证你和你的同事总是安装相同的版本。</li><li>它会为你的项目设置增加一个步骤。</li></ul><p>将 TypeScript 作为 devDependency 替代。这样当你运行 <code>npm install</code> 时，你和你的同事总是会得到正确的版本。你更新 TypeScript 的方式与更新任何其他包的方式相同。</p><p>你的 IDE 和构建工具会很乐意发现以这种方式安装的 TypeScript 版本。例如，在命令行中，你可以使用 npx 来运行由 npm 安装的 tsc 版本：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tsc</span></span></code></pre></div><p>下一个要考虑的依赖类型是类型依赖或 @types。如果库本身没有附带 TypeScript 类型声明，那么你可能仍然能在 DefinitelyTyped 上找到类型定义，这是一个社区维护的 JavaScript 库类型定义集合。DefinitelyTyped 的类型定义在 npm 注册表的 @types 作用域下发布：@types/jquery 有 jQuery 的类型定义，@types/lodash 有 Lodash 的类型，等等。这些 @types 包只包含类型，不包含实现。</p><p>你的 @types 依赖也应该是 devDependencies，即使包本身是直接依赖。例如，要依赖 React 及其类型声明，你可能会运行：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> react</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --save-dev</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> @types/react</span></span></code></pre></div><p>这将产生一个看起来像这样的 package.json 文件：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;devDependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;@types/react&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^18.2.23&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;typescript&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^5.2.2&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;dependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;react&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^18.2.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这里的想法是你应该发布 JavaScript，而不是 TypeScript，而你的 JavaScript 在运行时不依赖 @types。（TypeScript 用户可能依赖这些 @types，但最好避免传递类型依赖。Item 70 将向你展示如何做。）</p><p>如果你正在构建一个 Web 应用，没有打算将其作为库发布到 npm 上呢？你可能会发现建议说在这种情况下不值得分离 devDependencies，你不如把一切都作为生产依赖。然而，即使对于 Web 应用，将 @types 放在 devDependencies 中也有几个优势：</p><ul><li><p>如果你的应用有服务器组件，你可以运行 <code>npm install --production</code> 来只在生产镜像中安装生产依赖。假设你已经将 TypeScript 编译为 JavaScript，这些将是运行代码所需的唯一依赖。这将产生一个更小的镜像，启动更快。</p></li><li><p>如果你使用自动依赖更新工具（如 Renovate 或 Dependabot），你可以告诉它优先考虑生产依赖。这些更可能有重要的安全更新，可能会影响你代码的最终用户，这些是你应该关注的。</p></li></ul><p>@types 依赖可能会出现一些问题，下一个项目将深入探讨这个主题。</p><h2 id="要点回顾" tabindex="-1">要点回顾 <a class="header-anchor" href="#要点回顾" aria-label="Permalink to &quot;要点回顾&quot;">​</a></h2><ul><li>理解 <em>package.json</em> 中 <code>dependencies</code> 和 <code>devDependencies</code> 的区别。</li><li>将 TypeScript 放入项目的 <code>devDependencies</code> 中，不要全局安装 TypeScript。</li><li>将 <code>@types</code> 依赖放在 <code>devDependencies</code> 中，而不是 <code>dependencies</code> 中。</li></ul>`,26)]))}const y=s(n,[["render",t]]);export{o as __pageData,y as default};
